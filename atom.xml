<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dunwu</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/blog/"/>
  <updated>2021-08-26T15:33:01.461Z</updated>
  <id>https://dunwu.github.io/blog/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note/数据密集型应用系统设计</title>
    <link href="https://dunwu.github.io/blog/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://dunwu.github.io/blog/note/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-08-26T15:33:01.461Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据密集型应用系统设计"><a class="markdownIt-Anchor" href="#数据密集型应用系统设计"></a> 数据密集型应用系统设计</h1><h2 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h2><p>复制主要指通过互联网络在多台机器上保存相同数据的副本。</p><p>数据复制的作用：</p><ul><li>使数据在地理位置上更接近用户，从而<strong>降低访问延迟</strong>。</li><li>当部分组件出现位障，系统依然可以继续工作，从而<strong>提高可用性</strong>。</li><li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong>。</li></ul><p>复制方式：</p><ul><li>主从复制</li><li>多主节点复制</li><li>无主节点复制</li></ul><p>复制需要考虑的问题：</p><ul><li>同步还是异步</li><li>如何处理失败的副本</li><li>如何保证数据一致</li></ul><h3 id="主节点与从节点"><a class="markdownIt-Anchor" href="#主节点与从节点"></a> 主节点与从节点</h3><p>每个保存数据库完整数据集的节点称之为副本。</p><p>主从复制的工作原理如下：</p><ol><li>指定某一个副本为主副本（或称为主节点） 。当客户写数据库时，必须将写请求首先发送给主副本，主副本首先将新数据写入本地存储。</li><li>其他副本则全部称为从副本（或称为从节点）。主副本把新数据写入本地存储后，然后将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li><li>客户端从数据库中读数据时，可以在主副本或者从副本上执行查询。再次强调，只有主副本才可以接受写请求：从客户端的角度来看，从副本都是只读的。</li></ol><p>许多关系型数据库都内置支持主从复制，例如 PostgreSQL (9.0 版本以后）、MySQL 、Oracle Data Guard 和 SQL Server 的 AlwaysOn Availabilitiy Groups 。而一些非关系数据库如 MongoDB 、RethinkDB 和 Espresso 也支持主从复制。另外， 主从复制技术也不仅限于数据库，还广泛用于分布式悄息队列如 Kafka 和 RabbitMQ。</p><h3 id="同步复制与异步复制"><a class="markdownIt-Anchor" href="#同步复制与异步复制"></a> 同步复制与异步复制</h3><ul><li><strong>同步复制的优点</strong>： 一旦向用户确认，从节点可以明确保证完成了与主节点的更新同步，数据已经处于最新版本。万一主节点发生故障，总是可以在从节点继续访问最新数据。</li><li><strong>同步复制的缺点</strong>：如果同步的从节点无法完成确认（例如由于从节点发生崩愤，或者网络故障，或任何其他原因）， 写入就不能视为成功。主节点会阻塞其后所有的写操作，直到同步副本确认完成。</li></ul><p>因此，把所有从节点都配置为同步复制有些不切实际。因为这样的话，任何一个同步节点的中断都会导致整个系统更新停滞不前。</p><ul><li><strong>异步复制的优点</strong>：不管从节点上数据多么滞后， 主节点总是可以继续响应写请求，系统的吞吐性能更好。</li><li><strong>异步复制的缺点</strong>：如果主节点发生失败且不可恢复，则所有尚未复制到从节点的写请求都会丢失。</li></ul><h3 id="配置新的从节点"><a class="markdownIt-Anchor" href="#配置新的从节点"></a> 配置新的从节点</h3><ol><li>在某个时间点对主节点的数据副本产生一个一致性快照，这样避免长时间锁定整个数据库。目前大多数数据库都支持此功能，快照也是系统备份所必需的。而在某些情况下，可能需要第三方工具， 如 MySQL 的 innobackupex。</li><li>将此快照拷贝到新的从节点。</li><li>从节点连接到主节点并请求快照点之后所发生的数据更改日志。因为在第一步创建快照时，快照与系统复制日志的某个确定位置相关联，这个位置信息在不同的系统有不同的称呼，如 PostgreSQL 将其称为“ log sequence number” （日志序列号），而 MySQL 将其称为“ binlog coordinates ” 。</li><li>获得日志之后，从节点来应用这些快照点之后所有数据变更，这个过程称之为追赶。接下来，它可以继续处理主节点上新的数据变化。井重复步骤 1 ～步骤 4 。</li></ol><p>建立新的从副本具体操作步骤可能因数据库系统而异。</p><h3 id="处理节点失效"><a class="markdownIt-Anchor" href="#处理节点失效"></a> 处理节点失效</h3><p>如何通过主从复制技术来实现系统高可用呢？</p><h4 id="从节点失效-追赶式恢复"><a class="markdownIt-Anchor" href="#从节点失效-追赶式恢复"></a> 从节点失效： 追赶式恢复</h4><p>从节点的本地磁盘上都保存了副本收到的数据变更日志。如果从节点发生崩溃，然后顺利重启，或者主从节点之间的网络发生暂时中断（闪断），则恢复比较容易，根据副本的复制日志，从节点可以知道在发生故障之前所处理的最后一笔事务，然后连接到主节点，并请求自那笔事务之后中断期间内所有的数据变更。在收到这些数据变更日志之后，将其应用到本地来追赶主节点。之后就和正常情况一样持续接收来自主节点数据流的变化。</p><h4 id="主节点失效节点切换"><a class="markdownIt-Anchor" href="#主节点失效节点切换"></a> 主节点失效：节点切换</h4><p>选择某个从节点将其提升为主节点；客户端也需要更新，这样之后的写请求会发送给新的主节点，然后其他从节点要接受来自新的主节点上的变更数据，这一过程称之为切换。</p><p>步骤通常如下：</p><ol><li><strong>确认主节点失效</strong>。有很多种出错可能性，所以大多数系统都采用了基于超时的机制：节点间频繁地互相发生发送心跳悄息，如果发现某一个节点在一段比较长时间内（例如 30s ）没有响应，即认为该节点发生失效。</li><li><strong>选举新的主节点</strong>。可以通过选举的方式（超过多数的节点达成共识）来选举新的主节点，或者由之前选定的某控制节点来指定新的主节点。候选节点最好与原主节点的数据差异最小，这样可以最小化数据丢失的风险。让所有节点同意新的主节点是个典型的共识问题。</li><li><strong>重新配置系统使新主节点生效</strong>。客户端现在需要将写请求发送给新的主节点。如果原主节点之后重新上线，可能仍然自认为是主节点，而没有意识到其他节点已经达成共识迫使其下台。这时系统要确保原主节点降级为从节点，并认可新的主节点。</li></ol><p>上述切换过程依然充满了很多变数：</p><ul><li>如果使用了异步复制，且失效之前，新的主节点并未收到原主节点的所有数据；在选举之后，原主节点很快又重新上线并加入到集群，接下来的写操作会发生什么？新的主节点很可能会收到冲突的写请求，这是因为原主节点未意识的角色变化，还会尝试同步其他从节点，但其中的一个现在已经接管成为现任主节点。常见的解决方案是，原主节点上未完成复制的写请求就此丢弃，但这可能会违背数据更新持久化的承诺。</li><li>如果在数据库之外有其他系统依赖于数据库的内容并在一起协同使用，丢弃数据的方案就特别危险。例如，在 GitHub 的一个事故中，某个数据并非完全同步的 MySQL 从节点被提升为主副本，数据库使用了自增计数器将主键分配给新创建的行，但是因为新的主节点计数器落后于原主节点（ 即二者并非完全同步），它重新使用了已被原主节点分配出去的某些主键，而恰好这些主键已被外部 Redis 所引用，结果出现 MySQL 和 Redis 之间的不一致，最后导致了某些私有数据被错误地泄露给了其他用户。</li><li>在某些故障情况下，可能会发生两个节点同时－都自认为是主节点。这种情况被称为<strong>脑裂</strong>，它非常危险：两个主节点都可能接受写请求，并且没有很好解决冲突的办法（参阅本章后面的“多主节点复制技术”），最后数据可<br />能会丢失或者破坏。作为一种安全应急方案，有些系统会采取措施来强制关闭其中一个节点。然而，如果设计或者实现考虑不周，可能会出现两个节点都被关闭的情况。</li><li>如何设置合适的超时来检测主节点失效呢？ 主节点失效后，超时时间设置得越长也意味着总体恢复时间就越长。但如果超时设置太短，可能会导致很多不必要的切换。例如，突发的负载峰值会导致节点的响应时间变长甚至超肘，或者由于网络故障导致延迟增加。如果系统此时已经处于高负载压力或网络已经出现严重拥塞，不必要的切换操作只会使总体情况变得更糟。</li></ul><h4 id="复制日志的实现"><a class="markdownIt-Anchor" href="#复制日志的实现"></a> 复制日志的实现</h4><h5 id="基于语句的复制"><a class="markdownIt-Anchor" href="#基于语句的复制"></a> 基于语句的复制</h5><p>最简单的情况，主节点记录所执行的每个写请求（操作语句）井将该操作语句作为日志发送给从节点。对于关系数据库，这意味着每个 INSERT 、UPDATE 或 DELETE 语句都会转发给从节点，并且每个从节点都会分析井执行这些 SQU 吾句，如同它们是来自客户端那样。</p><p>听起来很合理也不复杂，但这种复制方式有一些不适用的场景：</p><ul><li>任何调用非确定性函数的语句，如 <code>NOW()</code> 获取当前时间，或 <code>RAND()</code> 获取一个随机数等，可能会在不同的副本上产生不同的值。</li><li>如果语句中使用了自增列，或者依赖于数据库的现有数据（例如， <code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则所有副本必须按照完全相同的顺序执行，否则可能会带来不同的结果。进而，如果有多个同时并发执行的事务时， 会有很大的限制。</li><li>有副作用的语句（例如，触发器、存储过程、用户定义的函数等），可能会在每个副本上产生不同的副作用。</li></ul><p>有可能采取一些特殊措施来解决这些问题，例如，主节点可以在记录操作语句时将非确定性函数替换为执行之后的确定的结果，这样所有节点直接使用相同的结果值。但是，这里面存在太多边界条件需要考虑，因此目前通常首选的是其他复制实现方案。</p><p>MySQL 5.1 版本之前采用基于操作语句的复制。现在由于逻辑紧凑，依然在用，但是默认情况下，如果语句中存在一些不确定性操作，则 MySQL 会切换到基于行的复制（稍后讨论）。VoltDB 使用基于语句的复制，它通过事务级别的确定性来保证复制的安全。</p><h5 id="基于预写日志wal传输"><a class="markdownIt-Anchor" href="#基于预写日志wal传输"></a> 基于预写日志（WAL）传输</h5><p>通常每个写操作都是以追加写的方式写入到日志中：</p><ul><li>对于日志结构存储引擎，日志是主要的存储方式。日志段在后台压缩井支持垃圾回收。</li><li>对于采用覆写磁盘的 BTree 结构，每次修改会预先写入日志，如系统发生崩愤，通过索引更新的方式迅速恢复到此前－致状态。</li></ul><p>不管哪种情况，所有对数据库写入的字节序列都被记入日志。因此可以使用完全相同的日志在另一个节点上构建副本：除了将日志写入磁盘之外， 主节点还可以通过网络将其发送给从节点。</p><p>PostgreSQL 、Oracle 以及其他系统等支持这种复制方式。其主要缺点是日志描述的数据结果非常底层： 一个 WAL 包含了哪些磁盘块的哪些字节发生改变，诸如此类的细节。这使得复制方案和存储引擎紧密搞合。如果数据库的存储格式从一个版本改为另一个版本，那么系统通常无能支持主从节点上运行不同版本的软件。</p><h5 id="基于行的逻辑日志复制"><a class="markdownIt-Anchor" href="#基于行的逻辑日志复制"></a> 基于行的逻辑日志复制</h5><p>关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求：</p><ul><li>对于行插入，日志包含所有相关列的新值。</li><li>对于行删除，日志里有足够的信息来唯一标识已删除的行，通常是靠主键，但如果表上没有定义主键，就需要记录所有列的旧值。</li><li>对于行更新，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少包含所有已更新列的新值）。</li></ul><p>如果一条事务涉及多行的修改，贝 lj 会产生多个这样的日志记录，并在后面跟着一条记录，指出该事务已经提交。MySQL 的二进制日志 binl og （当配置为基于行的复制时）使用该方式。</p><p>由于逻辑日志与存储引擎逻辑解锢，因此可以更容易地保持向后兼容，从而使主从节点能够运行不同版本的软件甚至是不同的存储引擎。<br />对于外部应用程序来说，逻辑日志格式也更容易解析。</p><h5 id="基于触发器的复制"><a class="markdownIt-Anchor" href="#基于触发器的复制"></a> 基于触发器的复制</h5><p>触发器支持注册自己的应用层代码，使得当数据库系统发生数据更改（写事务）时自动执行上述自定义代码。通过触发器技术，可以将数据更改记录到一个单独的表中，然后外部处理逻辑访问该表，实施必要的自定义应用层逻辑，例如将数据更改复制到另一个系统。Oracle 的 Databus 和 Postgres 的 Bucardo 就是这种技术的典型代表。基于触发器的复制通常比其他复制方式开销更高， 也比数据库内置复制更容易出错，或者暴露一些限制。然而，其高度灵活性仍有用武之地。</p><h3 id="复制滞后问题"><a class="markdownIt-Anchor" href="#复制滞后问题"></a> 复制滞后问题</h3><p>主从复制要求所有写请求都经由主节点，而任何副本只能接受只读查询。对于读操作密集的负载（如Web ），这是一个不错的选择：创建多个从副本，将读请求分发给这些从副本，从而减轻主节点负载井允许读取请求就近满足。</p><p>在这种扩展体系下，只需添加更多的从副本，就可以提高读请求的服务吞吐量。但是，这种方怯实际上只能用于异步复制，如果试图同步复制所有的从副本，则单个节点故障或网络中断将使整个系统无能写入。而且节点越多，发生故障的概率越高，所以完全同步的配置现实中反而非常不可靠。</p><p>不幸的是，如果一个应用正好从一个异步的从节点读取数据，而该副本落后于主节点， 贝lj应用可能会读到过期的信息。这会导致数据库中出现明显的不一致：由于并非所有的写入都反映在从副本上，如果同时对主节点和从节点发起相同的查询，可能会得到不同的结果。这种效应也破称为最终一致性。</p><h3 id="读自己的写"><a class="markdownIt-Anchor" href="#读自己的写"></a> 读自己的写</h3><p>许多应用让用户提交一些数据，接下来查看他们自己所提交的内容。例如客户数据库<br />中的记录，亦或者是讨论主题的评论等。提交新数据须发送到主节点，但是当用户读<br />取数据时，数据可能来自从节点。这对于读密集和偶尔写入的负载是个非常合适的方<br />案。<br />然而对于异步复制存在这样一个问题，如图5-3 所示，用户在写人不久即查看数据，<br />则新数据可能尚未到达从节点。对用户来讲， 看起来似乎是刚刚提交的数据丢失了，<br />显然用户不会高兴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据密集型应用系统设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据密集型应用系统设计&quot;&gt;&lt;/a&gt; 数据密集型应用系统设计&lt;/h1&gt;
&lt;h2 id=&quot;数据复制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>note/架构实战案例解析</title>
    <link href="https://dunwu.github.io/blog/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://dunwu.github.io/blog/note/%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2021-08-26T15:33:01.461Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构实战案例解析"><a class="markdownIt-Anchor" href="#架构实战案例解析"></a> 架构实战案例解析</h1><h2 id="架构的本质如何打造一个有序的系统"><a class="markdownIt-Anchor" href="#架构的本质如何打造一个有序的系统"></a> 架构的本质：如何打造一个有序的系统？</h2><p><strong>架构的本质</strong>：通过合理的内部编排，保证系统高度有序，能够不断扩展，满足业务和技术的变化。</p><p>首先，架构的出发点是业务和技术在不断复杂化，引起系统混乱，需要通过架构来保证有序。</p><p>其次，架构实现从无序到有序，是通过合理的内部编排实现的，基本的手段，就是“分”与“合”，先把系统打散，然后将它们重新组合，形成更合理的关系。</p><p><strong>架构的分类</strong></p><ul><li>业务架构</li><li>应用架构</li><li>技术架构</li></ul><p><strong>架构师的自我修养</strong></p><ul><li>优秀的程序员</li><li>沟通交流</li><li>权衡取舍</li><li>多领域知识</li><li>技术前瞻性</li><li>看透问题本质</li><li>抽象思维</li></ul><h2 id="业务架构作为开发你真的了解业务吗"><a class="markdownIt-Anchor" href="#业务架构作为开发你真的了解业务吗"></a> 业务架构：作为开发，你真的了解业务吗？</h2><p>产品经理的职责是定义产品的外观。</p><p>架构师的职责是将业务抽象为结构化的模块体系。</p><h2 id="可扩展架构如何打造一个善变的柔性系统"><a class="markdownIt-Anchor" href="#可扩展架构如何打造一个善变的柔性系统"></a> 可扩展架构：如何打造一个善变的柔性系统？</h2><p>系统 = 模块 + 关系</p><p>模块的要求：</p><ul><li>定位明确，概念完整</li><li>自成体系，粒度适中</li></ul><p>依赖关系的要求：</p><ul><li>最好是单向的</li><li>最好是层次化结构</li></ul><p>通过拆分，实现模块划分；通过整合，优化模块依赖关系。</p><h2 id="可扩展架构案例一电商平台架构是如何演变的"><a class="markdownIt-Anchor" href="#可扩展架构案例一电商平台架构是如何演变的"></a> 可扩展架构案例（一）：电商平台架构是如何演变的？</h2><p>电商平台的大致发展：</p><p>单体 -&gt; 分布式 -&gt; SOA -&gt; 微服务 -&gt; 中台</p><p>SOA vs. 微服务</p><ul><li>SOA 中的 ESB 采用集中式管理</li><li>微服务采用去中心化管理</li></ul><h2 id="可扩展架构案例二app-服务端架构是如何升级的"><a class="markdownIt-Anchor" href="#可扩展架构案例二app-服务端架构是如何升级的"></a> 可扩展架构案例（二）：App 服务端架构是如何升级的？</h2><h2 id="可扩展架构案例三你真的需要一个中台吗"><a class="markdownIt-Anchor" href="#可扩展架构案例三你真的需要一个中台吗"></a> 可扩展架构案例（三）：你真的需要一个中台吗？</h2><p>前台：面向 C 端的应用</p><p>后台：企业内部系统</p><p>中台：通过实现基础业务的平台化，实现了企业级业务能力的快速复用</p><h2 id="可复用架构如何实现高层次的复用"><a class="markdownIt-Anchor" href="#可复用架构如何实现高层次的复用"></a> 可复用架构：如何实现高层次的复用？</h2><p>技术复用</p><ul><li>代码复用</li><li>组件复用</li></ul><p>业务复用</p><h2 id="可复用架构案例一如何设计一个基础服务"><a class="markdownIt-Anchor" href="#可复用架构案例一如何设计一个基础服务"></a> 可复用架构案例（一）：如何设计一个基础服务？</h2><h2 id="可复用架构案例二如何对现有系统做微服务改造"><a class="markdownIt-Anchor" href="#可复用架构案例二如何对现有系统做微服务改造"></a> 可复用架构案例（二）：如何对现有系统做微服务改造？</h2><h2 id="可复用架构案例三中台是如何炼成的"><a class="markdownIt-Anchor" href="#可复用架构案例三中台是如何炼成的"></a> 可复用架构案例（三）：中台是如何炼成的？</h2><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://time.geekbang.org/column/intro/100046301" target="_blank" rel="noopener">架构实战案例解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;架构实战案例解析&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#架构实战案例解析&quot;&gt;&lt;/a&gt; 架构实战案例解析&lt;/h1&gt;
&lt;h2 id=&quot;架构的本质如何打造一个有序的系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从0开始学微服务学习笔记</title>
    <link href="https://dunwu.github.io/blog/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://dunwu.github.io/blog/note/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-08-15T07:27:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-0-开始学微服务学习笔记"><a class="markdownIt-Anchor" href="#从-0-开始学微服务学习笔记"></a> 从 0 开始学微服务学习笔记</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1">1. 到底什么是微服务？</a></li><li><a href="#2-%E4%BB%8E%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E8%B5%B0%E5%90%91%E6%9C%8D%E5%8A%A1%E5%8C%96">2. 从单体应用走向服务化</a><ul><li><a href="#21-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86">2.1. 什么时候进行服务化拆分？</a></li><li><a href="#22-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A7%BF%E5%8A%BF">2.2. 服务化拆分的两种姿势</a></li><li><a href="#23-%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%8B%86%E5%88%86%E7%9A%84%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6">2.3. 服务化拆分的前置条件</a></li></ul></li><li><a href="#3-%E5%88%9D%E6%8E%A2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84">3. 初探微服务架构</a></li><li><a href="#4-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">4. 如何发布和引用服务？</a></li><li><a href="#5-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1">5. 如何注册和发现服务？</a><ul><li><a href="#51-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">5.1. 注册中心实现方式</a></li><li><a href="#52-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2">5.2. 集群部署</a></li><li><a href="#53-%E7%9B%AE%E5%BD%95%E5%AD%98%E5%82%A8">5.3. 目录存储</a></li><li><a href="#54-%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B">5.4. 服务健康状态检测</a></li><li><a href="#55-%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E9%80%9A%E7%9F%A5">5.5. 服务状态变更通知</a></li><li><a href="#56-%E7%99%BD%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6">5.6. 白名单机制</a></li></ul></li><li><a href="#6-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-rpc-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">6. 如何实现 RPC 远程服务调用？</a></li><li><a href="#7-%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">7. 如何监控微服务调用？</a></li><li><a href="#8-%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">8. 如何追踪微服务调用？</a><ul><li><a href="#81-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%9A%84%E4%BD%9C%E7%94%A8">8.1. 服务追踪的作用</a></li><li><a href="#82-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">8.2. 服务追踪系统原理</a></li><li><a href="#83-%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">8.3. 服务追踪系统实现</a></li></ul></li><li><a href="#9-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B">9. 微服务治理的手段有哪些？</a><ul><li><a href="#91-%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86">9.1. 节点管理</a></li><li><a href="#92-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">9.2. 负载均衡</a></li><li><a href="#93-%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">9.3. 服务路由</a></li><li><a href="#94-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99">9.4. 服务容错</a></li></ul></li><li><a href="#10-dubbo-%E6%A1%86%E6%9E%B6%E9%87%8C%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6">10. Dubbo 框架里的微服务组件</a></li><li><a href="#11-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E8%B7%B5">11. 服务发布和引用的实践</a></li><li><a href="#12-%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0">12. 如何将注册中心落地？</a><ul><li><a href="#121-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">12.1. 注册中心工作流程</a></li><li><a href="#122-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E8%8A%82%E7%82%B9">12.2. 如何注册节点</a></li><li><a href="#123-%E5%A6%82%E4%BD%95%E5%8F%8D%E6%B3%A8%E5%86%8C">12.3. 如何反注册</a></li><li><a href="#124-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF">12.4. 如何查询节点信息</a></li><li><a href="#125-%E5%A6%82%E4%BD%95%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1%E5%8F%98%E6%9B%B4">12.5. 如何订阅服务变更</a></li><li><a href="#126-%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98">12.6. 注册与发现的几个问题</a></li></ul></li><li><a href="#13-%E5%BC%80%E6%BA%90%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">13. 开源服务注册中心如何选型？</a></li><li><a href="#14-%E5%BC%80%E6%BA%90-rpc-%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B">14. 开源 RPC 框架如何选型？</a></li><li><a href="#15-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%9A%84%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F">15. 如何搭建一个可靠的监控系统？</a></li><li><a href="#16-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E5%A5%97%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F">16. 如何搭建一套适合你的服务追踪系统？</a></li><li><a href="#17-%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB">17. 如何识别服务节点是否存活？</a><ul><li><a href="#171-%E5%BF%83%E8%B7%B3%E5%BC%80%E5%85%B3%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.1. 心跳开关保护机制</a></li><li><a href="#172-%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E6%91%98%E9%99%A4%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6">17.2. 服务节点摘除保护机制</a></li></ul></li><li><a href="#18-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18. 如何使用负载均衡算法？</a><ul><li><a href="#181-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95">18.1. 负载均衡算法</a></li></ul></li><li><a href="#19-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1">19. 如何使用服务路由？</a></li><li><a href="#20-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9">20. 服务端出现故障时该如何应对？</a></li><li><a href="#21-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%89%8B%E6%AE%B5">21. 服务调用失败时有哪些处理手段？</a></li><li><a href="#22-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE">22. 如何管理服务配置？</a></li><li><a href="#23-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0">23. 如何搭建微服务治理平台？</a></li><li><a href="#24-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AF%A5%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0">24. 微服务架构该如何落地？</a></li><li><a href="#25-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%B9%E5%99%A8%E5%8C%96">25. 微服务为什么要容器化？</a></li><li><a href="#26-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6">26. 微服务容器化运维：镜像仓库和资源调度</a></li><li><a href="#27-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%AE%B9%E5%99%A8%E8%B0%83%E5%BA%A6%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92">27. 微服务容器化运维：容器调度和服务编排</a></li><li><a href="#28-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%BE%AE%E5%8D%9A%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0-dcp">28. 微服务容器化运维：微博容器运维平台 DCP</a></li><li><a href="#29-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-devops">29. 微服务如何实现 DevOps？</a></li><li><a href="#30-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92">30. 如何做好微服务容量规划？</a></li><li><a href="#31-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%9A%E6%9C%BA%E6%88%BF%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">31. 微服务多机房部署实践</a></li><li><a href="#32-%E5%A4%9A%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">32. 多机房数据同步</a></li><li><a href="#33-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B7%B7%E5%90%88%E4%BA%91%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5">33. 微服务混合云部署实践</a><ul><li><a href="#331-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">33.1. 跨云服务的负载均衡</a></li><li><a href="#332-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5">33.2. 跨云服务的数据同步</a></li><li><a href="#333-%E8%B7%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E7%BB%B4">33.3. 跨云服务的容器运维</a></li></ul></li><li><a href="#34-%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-service-mesh">34. 下一代微服务架构 Service Mesh</a></li><li><a href="#35-service-mesh-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">35. Service Mesh 的实现原理</a></li><li><a href="#36-istioservice-mesh%E7%9A%84%E4%BB%A3%E8%A1%A8%E4%BA%A7%E5%93%81">36. Istio：Service Mesh 的代表产品</a><ul><li><a href="#361-istio-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84">36.1. Istio 整体架构</a></li></ul></li></ul><!-- /TOC --><h2 id="1-到底什么是微服务"><a class="markdownIt-Anchor" href="#1-到底什么是微服务"></a> 1. 到底什么是微服务？</h2><blockquote><p>微服务定义</p><p>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。</p><p>——Martin Fowler 和 James Lewis</p></blockquote><p>单体应用的问题</p><ul><li>部署效率低</li><li>团队协作开发成本高</li><li>单点故障问题</li><li>线上发布变慢</li></ul><p>服务化：本地方法调用 转为 远程方法调用（RPC）</p><p>微服务和服务化的差异：</p><ul><li>服务拆分粒度更细</li><li>服务独立部署、维护</li><li>服务治理要求高</li></ul><h2 id="2-从单体应用走向服务化"><a class="markdownIt-Anchor" href="#2-从单体应用走向服务化"></a> 2. 从单体应用走向服务化</h2><h3 id="21-什么时候进行服务化拆分"><a class="markdownIt-Anchor" href="#21-什么时候进行服务化拆分"></a> 2.1. 什么时候进行服务化拆分？</h3><p>经验：开发人员超过 10 人（沟通成本变高），就可以考虑服务化拆分</p><h3 id="22-服务化拆分的两种姿势"><a class="markdownIt-Anchor" href="#22-服务化拆分的两种姿势"></a> 2.2. 服务化拆分的两种姿势</h3><p><strong>纵向拆分</strong>，从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p><p><strong>横向拆分</strong>，从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p><h3 id="23-服务化拆分的前置条件"><a class="markdownIt-Anchor" href="#23-服务化拆分的前置条件"></a> 2.3. 服务化拆分的前置条件</h3><ul><li><strong>服务如何定义</strong>。通过接口来约定。</li><li><strong>服务如何发布和订阅</strong>。通过服务注册和发现。</li><li><strong>服务如何监控</strong>。<strong>故障如何定位</strong>。服务化需要链路监控。</li><li><strong>服务如何治理</strong>。超时和重试、流量控制。</li></ul><h2 id="3-初探微服务架构"><a class="markdownIt-Anchor" href="#3-初探微服务架构"></a> 3. 初探微服务架构</h2><p>微服务通过注册中心，实现发布订阅模式。</p><p>服务调用主要依赖几个基本组件：</p><ul><li>服务描述：常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。<ul><li>RESTful API 代表：Swagger</li><li>XML 代表：Dubbo</li><li>IDL 代表：Thrift、gRPC</li></ul></li><li>注册中心<ul><li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li><li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li><li>注册中心返回服务提供者地址列表给服务消费者。</li><li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li></ul></li><li>服务框架<ul><li>通信协议：选择 TCP、UDP、HTTP，还是其他？</li><li>数据传输方式：同步、异步、多路复用？</li><li>序列化方式：JDK 序列化、Json、二进制（Protobuf、Thrift）？</li></ul></li><li>服务监控<ul><li>数据采集</li><li>数据处理</li><li>数据展示</li></ul></li><li>服务追踪</li><li>工作原理：通过 requestId、spanId 分别表示一次请求、请求中的某一环节</li><li>服务治理：<ul><li>超时、重试</li><li>负载均衡</li><li>故障转移</li><li>流量控制</li></ul></li></ul><h2 id="4-如何发布和引用服务"><a class="markdownIt-Anchor" href="#4-如何发布和引用服务"></a> 4. 如何发布和引用服务？</h2><p><strong>RESTful API</strong>：主要被<strong>用作 HTTP 或者 HTTPS 协议的接口定义</strong>。代表：Eureka</p><p><strong>XML 配置</strong>：代表：Dubbo。工作步骤：</p><ul><li>服务提供者定义接口，并实现接口。</li><li>服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。</li><li>服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口。</li></ul><p>IDL 文件：IDL 就是接口描述语言（interface description language）的缩写。主要<strong>用作跨语言平台的服务之间的调用</strong>。有两种最常用的 IDL：Thrift、gRPC。</p><h2 id="5-如何注册和发现服务"><a class="markdownIt-Anchor" href="#5-如何注册和发现服务"></a> 5. 如何注册和发现服务？</h2><p>微服务架构下，主要有三种角色：</p><ul><li>服务提供者（RPC Server）</li><li>服务消费者（RPC Client）</li><li>服务注册中心（Registry）</li></ul><h3 id="51-注册中心实现方式"><a class="markdownIt-Anchor" href="#51-注册中心实现方式"></a> 5.1. 注册中心实现方式</h3><p>注册中心必须提供以下最基本的 API，例如：</p><ul><li><p>服务注册接口</p></li><li><p>服务注销接口</p></li><li><p>心跳汇报接口</p></li><li><p>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</p></li><li><p>服务变更查询接口</p></li><li><p>服务查询接口</p></li><li><p>服务修改接口</p></li></ul><h3 id="52-集群部署"><a class="markdownIt-Anchor" href="#52-集群部署"></a> 5.2. 集群部署</h3><p>注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p><p>以 ZooKeeper 的工作原理为例：</p><ul><li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li><li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li><li>Leader 负责处理数据更新等操作（ZAB 协议）。</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li></ul><h3 id="53-目录存储"><a class="markdownIt-Anchor" href="#53-目录存储"></a> 5.3. 目录存储</h3><p>注册中心存储服务信息一般采用层次化的目录结构：</p><ul><li>每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。</li><li>znode 可以包含数据和子 znode。</li><li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li></ul><h3 id="54-服务健康状态检测"><a class="markdownIt-Anchor" href="#54-服务健康状态检测"></a> 5.4. 服务健康状态检测</h3><p>ZooKeeper 客户端和服务端维持的是一个长连接。连接成功后，会生成一个全局唯一的 Session ID，客户端定期发送心跳消息，服务端收到后重置会话超时时间。如果超时，则认为连接结束。</p><p>如果一个服务将 ZooKeeper 作为服务注册中心，一旦连接超时，ZooKeeper 会认为这个服务节点已经不可用，就会将其信息删除。</p><h3 id="55-服务状态变更通知"><a class="markdownIt-Anchor" href="#55-服务状态变更通知"></a> 5.5. 服务状态变更通知</h3><p>ZooKeeper 支持 Watch 机制。服务消费者可以监听服务提供者的节点信息。一旦服务提供者的节点信息哟变化，就可以获取到变更状态。</p><h3 id="56-白名单机制"><a class="markdownIt-Anchor" href="#56-白名单机制"></a> 5.6. 白名单机制</h3><p>通常注册中心会有多套环境，区分开发、测试、线上等环境。如果弄错了，会出现意想不到的后果，为此需要引入白名单保护机制。只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p><h2 id="6-如何实现-rpc-远程服务调用"><a class="markdownIt-Anchor" href="#6-如何实现-rpc-远程服务调用"></a> 6. 如何实现 RPC 远程服务调用？</h2><p>客户端和服务端如何建立网络连接？</p><ul><li><strong>HTTP 通信</strong>：三次握手建立连接；四次挥手断开连接</li><li><strong>Socket 通信</strong><ul><li>服务器监听</li><li>客户端请求</li><li>连接确认</li><li>数据传输</li></ul></li></ul><p>服务端如何处理请求？</p><ul><li>BIO</li><li>NIO</li><li>AIO</li></ul><p>数据传输采用什么协议？</p><ul><li>Http</li><li>Dubbo</li></ul><p>数据该如何序列化和反序列化？</p><ul><li>JDK</li><li>JSON</li><li>二进制（PB、Thrift 等）</li></ul><h2 id="7-如何监控微服务调用"><a class="markdownIt-Anchor" href="#7-如何监控微服务调用"></a> 7. 如何监控微服务调用？</h2><p>监控对象</p><ul><li>客户端监控</li><li>接口监控</li><li>资源监控</li><li>基础监控</li></ul><p>监控指标</p><ul><li>请求量</li><li>响应时间</li><li>错误率</li></ul><p>监控维度</p><ul><li>全局维度</li><li>机房维度</li><li>单机维度</li><li>时间维度</li><li>重要性维度</li></ul><p>监控关键点</p><ul><li>数据采集<ul><li>主动上报</li><li>代理收集</li></ul></li><li>数据传输<ul><li>UDP</li><li>Kafka</li></ul></li><li>数据处理<ul><li>全文检索：如 Elasticsearch</li><li>时序数据库：如 InfluxDB、OpenTSDB</li><li>流计算：如 Spark、Storm、Flink</li></ul></li><li>数据展示</li></ul><h2 id="8-如何追踪微服务调用"><a class="markdownIt-Anchor" href="#8-如何追踪微服务调用"></a> 8. 如何追踪微服务调用？</h2><h3 id="81-服务追踪的作用"><a class="markdownIt-Anchor" href="#81-服务追踪的作用"></a> 8.1. 服务追踪的作用</h3><ul><li>定位整个系统的瓶颈点</li><li>优化链路调用</li><li>生成网络拓扑</li><li>透明传输数据</li></ul><h3 id="82-服务追踪系统原理"><a class="markdownIt-Anchor" href="#82-服务追踪系统原理"></a> 8.2. 服务追踪系统原理</h3><p>经典论文：<a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener"><code>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</code></a></p><ul><li><strong>traceId</strong>，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li><li><strong>spanId</strong>，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li><li><strong>annotation</strong>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li></ul><h3 id="83-服务追踪系统实现"><a class="markdownIt-Anchor" href="#83-服务追踪系统实现"></a> 8.3. 服务追踪系统实现</h3><p>服务追踪系统可以分为三层。</p><ul><li>数据采集层，负责数据埋点并上报。</li><li>数据处理层，负责数据的存储与计算。</li><li>数据展示层，负责数据的图形化展示。</li></ul><h2 id="9-微服务治理的手段有哪些"><a class="markdownIt-Anchor" href="#9-微服务治理的手段有哪些"></a> 9. 微服务治理的手段有哪些？</h2><p>服务调用失败原因：</p><ul><li>服务提供者自身问题，如宕机、进程退出等；</li><li>网络问题</li></ul><h3 id="91-节点管理"><a class="markdownIt-Anchor" href="#91-节点管理"></a> 9.1. 节点管理</h3><ul><li><strong>注册中心主动摘除机制</strong>：服务提供者定时发送心跳，如果超时，注册中心把节点从服务列表中删除</li><li><strong>服务消费者摘除机制</strong>：如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除。</li></ul><h3 id="92-负载均衡"><a class="markdownIt-Anchor" href="#92-负载均衡"></a> 9.2. 负载均衡</h3><ul><li>随机算法</li><li>轮询算法</li><li>最少活跃调用算法</li><li>一致性 Hash 算法</li></ul><h3 id="93-服务路由"><a class="markdownIt-Anchor" href="#93-服务路由"></a> 9.3. 服务路由</h3><p>为什么要制定路由规则呢？</p><ul><li>业务存在灰度发布的需求</li><li>多机房就近访问的需求</li></ul><p>如何配置路由规则</p><ul><li>静态配置：修改服务消费者本地配置，上线后生效</li><li>动态配置：修改注册中心的配置，服务消费者在下一个同步周期之后，就会动态更新</li></ul><h3 id="94-服务容错"><a class="markdownIt-Anchor" href="#94-服务容错"></a> 9.4. 服务容错</h3><ul><li>FailOver：失败自动切换。</li><li>FailBack：失败通知。</li><li>FailCache：失败缓存。</li><li>FailFast：快速失败。</li></ul><p>一般情况下对于幂等的调用，可以选择 FailOver 或者 FailCache，非幂等的调用可以选择 FailBack 或者 FailFast。</p><h2 id="10-dubbo-框架里的微服务组件"><a class="markdownIt-Anchor" href="#10-dubbo-框架里的微服务组件"></a> 10. Dubbo 框架里的微服务组件</h2><h2 id="11-服务发布和引用的实践"><a class="markdownIt-Anchor" href="#11-服务发布和引用的实践"></a> 11. 服务发布和引用的实践</h2><p>XML 配置方式的服务发布和引用流程</p><ul><li>服务提供者定义接口</li><li>服务提供者发布接口</li><li>服务消费者引用接口</li></ul><p>服务发布和引用的那些坑</p><h2 id="12-如何将注册中心落地"><a class="markdownIt-Anchor" href="#12-如何将注册中心落地"></a> 12. 如何将注册中心落地？</h2><p>注册中心如何存储服务信息</p><p>服务一般会分成多个不同的分组</p><ul><li>核心与非核心，从业务的核心程度来分。</li><li>机房，从机房的维度来分。</li><li>线上环境与测试环境，从业务场景维度来区分。</li></ul><p>所以注册中心存储的服务信息一般包含三部分内容：<strong>分组</strong>、<strong>服务名</strong>以及<strong>节点信息</strong>，节点信息又包括节点地址和节点其他信息。</p><h3 id="121-注册中心工作流程"><a class="markdownIt-Anchor" href="#121-注册中心工作流程"></a> 12.1. 注册中心工作流程</h3><ul><li>服务提供者注册流程。</li><li>服务提供者反注册流程。</li><li>服务消费者查询流程。</li><li>服务消费者订阅变更流程。</li></ul><h3 id="122-如何注册节点"><a class="markdownIt-Anchor" href="#122-如何注册节点"></a> 12.2. 如何注册节点</h3><ul><li>首先查看要注册的节点是否在白名单内？如果不在就抛出异常，在的话继续下一步。</li><li>其次要查看注册的 Cluster（服务的接口名）是否存在？如果不存在就抛出异常，存在的话继续下一步。</li><li>然后要检查 Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下一步。</li><li>最后将节点信息添加到对应的 Service 和 Cluster 下面的存储中。</li></ul><h3 id="123-如何反注册"><a class="markdownIt-Anchor" href="#123-如何反注册"></a> 12.3. 如何反注册</h3><ul><li>查看 Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下一步。</li><li>查看 Cluster（服务的接口名）是否存在，不存在就抛出异常，存在就继续下一步。</li><li>删除存储中 Service 和 Cluster 下对应的节点信息。</li><li>更新 Cluster 的 sign 值。</li></ul><h3 id="124-如何查询节点信息"><a class="markdownIt-Anchor" href="#124-如何查询节点信息"></a> 12.4. 如何查询节点信息</h3><p>首先从 localcache（本机内存）中查找，如果没有就继续下一步。</p><p>接着从 snapshot（本地快照）中查找，如果没有就继续下一步。</p><h3 id="125-如何订阅服务变更"><a class="markdownIt-Anchor" href="#125-如何订阅服务变更"></a> 12.5. 如何订阅服务变更</h3><ul><li>服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的 sign 值。</li><li>服务消费者每隔一段时间，调用 getSign() 函数，从注册中心获取服务端该 Cluster 的 sign 值，并与本地保留的 sign 值做对比，如果不一致，就从服务端拉取新的节点信息，并更新 localcache 和 snapshot。</li></ul><h3 id="126-注册与发现的几个问题"><a class="markdownIt-Anchor" href="#126-注册与发现的几个问题"></a> 12.6. 注册与发现的几个问题</h3><ul><li><p>多注册中心</p></li><li><p>并行订阅服务</p></li><li><p>批量反注册服务</p></li><li><p>服务变更信息增量更新</p></li></ul><h2 id="13-开源服务注册中心如何选型"><a class="markdownIt-Anchor" href="#13-开源服务注册中心如何选型"></a> 13. 开源服务注册中心如何选型？</h2><ul><li><strong>应用内注册与发现</strong>：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。典型代表：Eureka</li><li><strong>应用外注册与发现</strong>：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。典型代表：Consul</li></ul><p>二者对比：</p><ul><li>用内的解决方案一般适用于服务提供者和服务消费者同属于一个技术体系；</li><li>应用外的解决方案一般适合服务提供者和服务消费者采用了不同技术体系的业务场景</li></ul><p>注册中心选型要考虑的两个问题</p><ul><li>高可用性</li><li>数据一致性<ul><li>CP 型：牺牲可用性来保证数据强一致性。代表：ZooKeeper、Etcd、Consul</li><li>AP 型：代表：Eureka、Nacos</li></ul></li></ul><p>而对于注册中心来说，最主要的功能是服务的注册和发现，在网络出现问题的时候，可用性的需求要远远高于数据一致性。即使因为数据不一致，注册中心内引入了不可用的服务节点，也可以通过其他措施来避免，比如客户端的快速失败机制等，只要实现最终一致性，对于注册中心来说就足够了。因此，选择 AP 型注册中心，一般更加合适。</p><h2 id="14-开源-rpc-框架如何选型"><a class="markdownIt-Anchor" href="#14-开源-rpc-框架如何选型"></a> 14. 开源 RPC 框架如何选型？</h2><p>限定语言 RPC</p><ul><li>Dubbo：仅支持 Java</li><li>Motan：仅支持 Java</li><li>Tars：仅支持 C++</li><li>Spring Cloud：仅支持 Java</li></ul><p>跨语言 RPC</p><ul><li>gRPC：支持 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言</li><li>Thrift：支持 C++、Java、PHP、Python、Ruby、Erlang 等多种语言</li></ul><h2 id="15-如何搭建一个可靠的监控系统"><a class="markdownIt-Anchor" href="#15-如何搭建一个可靠的监控系统"></a> 15. 如何搭建一个可靠的监控系统？</h2><p>日志解决方案：<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">ELK</a></p><p>时序数据库解决方案：<a href="http://graphite.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Graphite</a>、<a href="https://www.influxdata.com/time-series-platform/" target="_blank" rel="noopener">TICK</a>和<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a></p><h2 id="16-如何搭建一套适合你的服务追踪系统"><a class="markdownIt-Anchor" href="#16-如何搭建一套适合你的服务追踪系统"></a> 16. 如何搭建一套适合你的服务追踪系统？</h2><p>代表：Zipkin、PinPoint</p><h2 id="17-如何识别服务节点是否存活"><a class="markdownIt-Anchor" href="#17-如何识别服务节点是否存活"></a> 17. 如何识别服务节点是否存活？</h2><h3 id="171-心跳开关保护机制"><a class="markdownIt-Anchor" href="#171-心跳开关保护机制"></a> 17.1. 心跳开关保护机制</h3><p>问题：服务消费者同时并发访问注册中心获取最新服务信息导致注册中心带宽被打满</p><p>方案：需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。</p><h3 id="172-服务节点摘除保护机制"><a class="markdownIt-Anchor" href="#172-服务节点摘除保护机制"></a> 17.2. 服务节点摘除保护机制</h3><p>问题：服务提供者节点被大量摘除导致服务消费者没有足够的节点可以调用</p><p>方案：需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。</p><p>静态注册中心</p><h2 id="18-如何使用负载均衡算法"><a class="markdownIt-Anchor" href="#18-如何使用负载均衡算法"></a> 18. 如何使用负载均衡算法？</h2><h3 id="181-负载均衡算法"><a class="markdownIt-Anchor" href="#181-负载均衡算法"></a> 18.1. 负载均衡算法</h3><ul><li><p><strong>随机算法</strong></p></li><li><p><strong>轮询算法</strong></p></li><li><p><strong>加权轮询算法</strong></p></li><li><p><strong>最少活跃连接算法</strong></p></li><li><p><strong>一致性 hash 算法</strong></p></li></ul><h2 id="19-如何使用服务路由"><a class="markdownIt-Anchor" href="#19-如何使用服务路由"></a> 19. 如何使用服务路由？</h2><p><strong>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求</strong>。</p><p>服务路由的应用场景</p><ul><li><strong>分组调用</strong></li><li><strong>灰度发布</strong></li><li><strong>流量切换</strong></li><li><strong>读写分离</strong></li></ul><p>服务路由的规则</p><ul><li>条件路由<ul><li>排除某个服务节点</li><li>白名单和黑名单功能</li><li>机房隔离</li><li>读写分离</li></ul></li><li>脚本路由</li></ul><p>服务路由的获取方式</p><ul><li>本地配置</li><li>配置中心管理</li><li>动态下发</li></ul><h2 id="20-服务端出现故障时该如何应对"><a class="markdownIt-Anchor" href="#20-服务端出现故障时该如何应对"></a> 20. 服务端出现故障时该如何应对？</h2><p>微服务故障种类</p><ul><li>集群故障。解决：流量控制<ul><li>限流</li><li>降级</li></ul></li><li>单 IDC 故障。解决：多 IDC 部署、流量切换<ul><li>多 IDC 部署<ul><li>同城多活</li><li>异地多活</li></ul></li><li>流量切换<ul><li>DNS 解析流量切换</li><li>RPC 流量切换</li></ul></li></ul></li><li>单机故障</li></ul><h2 id="21-服务调用失败时有哪些处理手段"><a class="markdownIt-Anchor" href="#21-服务调用失败时有哪些处理手段"></a> 21. 服务调用失败时有哪些处理手段？</h2><p>超时</p><p>重试</p><p>流量控制</p><h2 id="22-如何管理服务配置"><a class="markdownIt-Anchor" href="#22-如何管理服务配置"></a> 22. 如何管理服务配置？</h2><p>配置类型：</p><ul><li>本地配置</li><li>配置中心</li></ul><p>配置中心代表：</p><ul><li><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">Spring Cloud Config</a></li><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo</a></li></ul><h2 id="23-如何搭建微服务治理平台"><a class="markdownIt-Anchor" href="#23-如何搭建微服务治理平台"></a> 23. 如何搭建微服务治理平台？</h2><p>服务管理</p><ul><li>服务上下线</li><li>节点添加 / 删除</li><li>服务查询</li><li>服务节点查询。这个操作会调用注册中心的节点查询接口，来查询某个服务下一共有多少个节点。</li></ul><p>服务治理</p><ul><li>限流</li><li>降级</li><li>切流量</li></ul><p>服务监控</p><p>问题定位</p><p>日志查询</p><p>服务运维</p><ul><li>发布部署</li><li>弹性伸缩</li></ul><h2 id="24-微服务架构该如何落地"><a class="markdownIt-Anchor" href="#24-微服务架构该如何落地"></a> 24. 微服务架构该如何落地？</h2><p>（略）</p><h2 id="25-微服务为什么要容器化"><a class="markdownIt-Anchor" href="#25-微服务为什么要容器化"></a> 25. 微服务为什么要容器化？</h2><p>微服务引入的问题</p><p>设计复杂</p><p>测试复杂</p><p>运维困难</p><h2 id="26-微服务容器化运维镜像仓库和资源调度"><a class="markdownIt-Anchor" href="#26-微服务容器化运维镜像仓库和资源调度"></a> 26. 微服务容器化运维：镜像仓库和资源调度</h2><p>容器运维平台的组成部分</p><ul><li>镜像仓库</li><li>资源调度</li><li>容器调度</li><li>服务编排</li></ul><h2 id="27-微服务容器化运维容器调度和服务编排"><a class="markdownIt-Anchor" href="#27-微服务容器化运维容器调度和服务编排"></a> 27. 微服务容器化运维：容器调度和服务编排</h2><p>容器调度系统代表：<a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Swarm</a>、<a href="http://mesos.apache.org/" target="_blank" rel="noopener">Mesos</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a></p><p>容器调度要解决的问题</p><ul><li><strong>主机过滤</strong><ul><li>存活过滤</li><li>硬件过滤</li></ul></li><li><strong>调度策略</strong></li><li><strong>服务编排</strong></li><li><strong>服务依赖</strong>：代表方案：<a href="https://github.com/docker/compose" target="_blank" rel="noopener">Docker Compose</a></li><li><strong>服务发现</strong><ul><li>基于 Nginx 的服务发现</li><li>基于注册中心的服务发现</li><li>弹性伸缩</li></ul></li></ul><h2 id="28-微服务容器化运维微博容器运维平台-dcp"><a class="markdownIt-Anchor" href="#28-微服务容器化运维微博容器运维平台-dcp"></a> 28. 微服务容器化运维：微博容器运维平台 DCP</h2><h2 id="29-微服务如何实现-devops"><a class="markdownIt-Anchor" href="#29-微服务如何实现-devops"></a> 29. 微服务如何实现 DevOps？</h2><ul><li><strong>CI（Continuous Integration）</strong>，持续集成。开发完成代码开发后，能自动地进行代码检查、单元测试、打包部署到测试环境，进行集成测试，跑自动化测试用例。<ul><li>代码检查</li><li>单元测试</li><li>集成测试</li></ul></li><li><strong>CD（Continuous Deploy）</strong>，持续部署。代码测试通过后，能自动部署到类生产环境中进行集成测试，测试通过后再进行小流量的灰度验证，验证通过后代码就达到线上发布的要求了，就可以把代码自动部署到线上。</li></ul><h2 id="30-如何做好微服务容量规划"><a class="markdownIt-Anchor" href="#30-如何做好微服务容量规划"></a> 30. 如何做好微服务容量规划？</h2><p>微服务容量规划的问题</p><ul><li>服务数量众多</li><li>服务的接口表现差异巨大</li><li>服务部署的集群规模大小不同</li><li>服务之间还存在依赖关系</li></ul><p>容量规划系统的作用是<strong>根据各个微服务部署集群的最大容量和线上实际运行的负荷，来决定各个微服务是否需要弹性扩缩容，以及需要扩缩容多少台机器</strong>。</p><p>容量规划系统实施的关键在于两点：</p><ul><li>容量评估<ul><li>选择合适的压测指标<ul><li>系统类指标：CPU、内存、I/O、带宽等</li><li>服务类指标：响应时间、P999 耗时、错误率等</li></ul></li><li>压测获取单机的最大容量<ul><li>单机压测<ul><li>通过日志回放等手段，模拟线上流量来对单机进行压测；</li><li>通过 TCP-Copy 的方式，把线上机器的流量拷贝过来对单机进行压测。</li></ul></li><li>集群压测</li></ul></li><li>实时和获取集群的运行负荷</li></ul></li><li>调度决策<ul><li>可以使用<strong>水位线</strong>来进行调度决策：当集群的水位线位于致命线以下时，就需要立即扩容，在扩容一定数量的机器后，水位线回到安全线以上并保持一段时间后，就可以进行缩容了。</li><li>扩容<ul><li>按数量</li><li>按比例</li></ul></li><li>缩容</li><li>逐步缩容</li><li>为了避免因扩容、缩容导致的水位线抖动，可以多次采集水位线数据，超过 60% 数据满足库哦哦让条件，才真正触发扩容。</li></ul></li></ul><h2 id="31-微服务多机房部署实践"><a class="markdownIt-Anchor" href="#31-微服务多机房部署实践"></a> 31. 微服务多机房部署实践</h2><p>多机房负载均衡：利用七层负载均衡和四层负载均衡，将流量根据用户就近访问的原则切分流量。</p><h2 id="32-多机房数据同步"><a class="markdownIt-Anchor" href="#32-多机房数据同步"></a> 32. 多机房数据同步</h2><h4 id="主从机房架构"><a class="markdownIt-Anchor" href="#主从机房架构"></a> 主从机房架构</h4><ul><li>由主机房的处理机来更新本机房的缓存和数据库</li><li>其他机房的缓存也通过主机房的处理机来更新</li><li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li></ul><h4 id="独立机房架构"><a class="markdownIt-Anchor" href="#独立机房架构"></a> 独立机房架构</h4><ul><li>每个机房的处理机接收到写请求后更新各自机房的缓存</li><li>只有主机房会更新数据库</li><li>从机房的数据库则通过 MySQL 的 binlog 同步主机房的数据。</li></ul><p>WMB 消息同步组件的功能就是把一个机房的写请求发给另外一个机房</p><ul><li>reship，负责把本机房的写请求分发一份给别的机房。</li><li>collector，负责从别的机房读取写请求，然后再把请求转发给本机房的处理机。</li></ul><p>实现 WMB 的消息同步功能有两种方案：</p><ul><li>MQ：两个机房的 MQ 通过维护状态机来读写请求</li><li>RPC</li></ul><h4 id="多机房数据一致性"><a class="markdownIt-Anchor" href="#多机房数据一致性"></a> 多机房数据一致性</h4><h2 id="33-微服务混合云部署实践"><a class="markdownIt-Anchor" href="#33-微服务混合云部署实践"></a> 33. 微服务混合云部署实践</h2><h3 id="331-跨云服务的负载均衡"><a class="markdownIt-Anchor" href="#331-跨云服务的负载均衡"></a> 33.1. 跨云服务的负载均衡</h3><p>当服务上云后还需要考虑把一定比例的用户请求路由到云上部署的服务</p><h3 id="332-跨云服务的数据同步"><a class="markdownIt-Anchor" href="#332-跨云服务的数据同步"></a> 33.2. 跨云服务的数据同步</h3><p>私有云与公有云之间的网络隔离</p><p>一般来讲，出于安全的需要，企业内部机房同公有云机房之间的网络是隔离的，为了实现互通，需要架设专门的 VPN 网络或者专线。</p><p>数据库能否上云</p><p>数据库能否上云的关键取决于数据的隐私性。</p><h3 id="333-跨云服务的容器运维"><a class="markdownIt-Anchor" href="#333-跨云服务的容器运维"></a> 33.3. 跨云服务的容器运维</h3><p>跨云的主机管理：跨云主机管理的关键点在于，如何对内部私有云的机器和公有云的 ECS 进行管理，</p><p>跨云服务发现</p><p>跨云弹性扩容</p><p>跨云服务编排</p><h2 id="34-下一代微服务架构-service-mesh"><a class="markdownIt-Anchor" href="#34-下一代微服务架构-service-mesh"></a> 34. 下一代微服务架构 Service Mesh</h2><p>为什么需要 Service Mesh</p><ul><li><p>跨语言服务调用的需要</p></li><li><p>云原生应用服务治理的需要</p></li></ul><h2 id="35-service-mesh-的实现原理"><a class="markdownIt-Anchor" href="#35-service-mesh-的实现原理"></a> 35. Service Mesh 的实现原理</h2><p>Service Mesh 实现的关键点：</p><ul><li>轻量级网络代理 SideCar，它的作用就是转发服务之间的调用；</li><li>基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。</li><li>服务发现</li><li>负载均衡</li><li>请求路由</li><li>故障处理</li><li>安全认证</li><li>监控上报</li><li>日志记录</li><li>配额控制</li></ul><h2 id="36-istioservice-mesh-的代表产品"><a class="markdownIt-Anchor" href="#36-istioservice-mesh-的代表产品"></a> 36. Istio：Service Mesh 的代表产品</h2><h3 id="361-istio-整体架构"><a class="markdownIt-Anchor" href="#361-istio-整体架构"></a> 36.1. Istio 整体架构</h3><p>Istio 的架构可以说由两部分组成，分别是 Proxy 和 Control Plane。</p><ul><li>Proxy，就是前面提到的 SideCar，与应用程序部署在同一个主机上，应用程序之间的调用都通过 Proxy 来转发，目前支持 HTTP/1.1、HTTP/2、gRPC 以及 TCP 请求。</li><li>Control Plane，与 Proxy 通信，来实现各种服务治理功能，包括三个基本组件：Pilot、Mixer 以及 Citadel。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从-0-开始学微服务学习笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#从-0-开始学微服务学习笔记&quot;&gt;&lt;/a&gt; 从 0 开始学微服务学习笔记&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://dunwu.github.io/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="微服务" scheme="https://dunwu.github.io/blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="RPC" scheme="https://dunwu.github.io/blog/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>左耳听风学习笔记</title>
    <link href="https://dunwu.github.io/blog/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://dunwu.github.io/blog/note/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-15T07:27:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左耳听风学习笔记"><a class="markdownIt-Anchor" href="#左耳听风学习笔记"></a> 左耳听风学习笔记</h1><h2 id="洞悉技术的本质"><a class="markdownIt-Anchor" href="#洞悉技术的本质"></a> 洞悉技术的本质</h2><h2 id="分布式系统架构的本质"><a class="markdownIt-Anchor" href="#分布式系统架构的本质"></a> 分布式系统架构的本质</h2><p>分布式系统架构的优点：</p><ul><li>高性能</li><li>高可用</li></ul><p>分布式系统架构的缺点：</p><ul><li>设计复杂</li><li>运维复杂</li></ul><p>分布式系统的技术栈</p><p>提高性能的技术</p><ul><li>缓存</li><li>负载均衡</li><li>异步</li><li>分片</li></ul><p>提供可用性的技术</p><ul><li>服务拆分</li><li>服务冗余</li><li>流量控制</li><li>高可用架构：多租户、多活架构、灾备</li><li>高可用运维：监控、DevOps</li></ul><p>分布式系统的关键技术</p><ul><li>服务治理</li><li>服务、资源调度</li><li>DevOps</li><li>监控</li></ul><h2 id="编程范式游记"><a class="markdownIt-Anchor" href="#编程范式游记"></a> 编程范式游记</h2><h2 id="分布式系统设计模式"><a class="markdownIt-Anchor" href="#分布式系统设计模式"></a> 分布式系统设计模式</h2><h2 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h2><h2 id="程序员练级攻略"><a class="markdownIt-Anchor" href="#程序员练级攻略"></a> 程序员练级攻略</h2><h2 id="面试攻略"><a class="markdownIt-Anchor" href="#面试攻略"></a> 面试攻略</h2><h2 id="高效学习"><a class="markdownIt-Anchor" href="#高效学习"></a> 高效学习</h2><p>浅度学习和深度学习</p><ul><li><strong>高质量的信息源和第一手的知识</strong>。</li><li><strong>把知识连成地图，将自己的理解反述出来</strong>。</li><li><strong>不断地反思和思辨，与不同年龄段的人讨论</strong>。</li><li><strong>举一反三，并践行之，把知识转换成技能</strong>。</li></ul><p>深度，归纳和坚持实践</p><ol><li><strong>这个技术出现的背景、初衷和目标</strong>。</li><li><strong>这个技术的优势和劣势分别是什么</strong></li><li><strong>这个技术适用的场景</strong></li><li><strong>技术的组成部分和关键点</strong>。</li><li><strong>技术的底层原理和关键实现</strong>。</li><li><strong>已有的实现和它之间的对比</strong>。</li></ol><h2 id="高效沟通"><a class="markdownIt-Anchor" href="#高效沟通"></a> 高效沟通</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;左耳听风学习笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#左耳听风学习笔记&quot;&gt;&lt;/a&gt; 左耳听风学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;洞悉技术的本质&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#洞悉技术
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://dunwu.github.io/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="架构" scheme="https://dunwu.github.io/blog/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统设计40问学习笔记</title>
    <link href="https://dunwu.github.io/blog/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/"/>
    <id>https://dunwu.github.io/blog/note/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE/</id>
    <published>2021-08-05T15:42:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高并发系统设计-40-问学习笔记"><a class="markdownIt-Anchor" href="#高并发系统设计-40-问学习笔记"></a> 高并发系统设计 40 问学习笔记</h1><h2 id="基础篇"><a class="markdownIt-Anchor" href="#基础篇"></a> 基础篇</h2><h3 id="高并发系统它的通用设计方法是什么"><a class="markdownIt-Anchor" href="#高并发系统它的通用设计方法是什么"></a> 高并发系统：它的通用设计方法是什么？</h3><p>并发、异步、缓存</p><h3 id="架构分层我们为什么一定要这么做"><a class="markdownIt-Anchor" href="#架构分层我们为什么一定要这么做"></a> 架构分层：我们为什么一定要这么做？</h3><p>分层架构典型代表：</p><ul><li>MVC（Model-View-Controller）</li><li>表现层、逻辑层和数据访问层</li><li>OSI 七层网络模型</li></ul><p>分层的好处</p><ul><li><strong>分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。</strong></li><li><strong>再有，分层之后可以做到很高的复用。</strong></li><li><strong>分层架构可以让我们更容易做横向扩展。</strong></li></ul><p>分层架构的不足</p><ul><li>增加了代码的复杂度</li></ul><h3 id="系统设计目标一如何提升系统性能"><a class="markdownIt-Anchor" href="#系统设计目标一如何提升系统性能"></a> 系统设计目标（一）：如何提升系统性能？</h3><p>讲述了性能指标和性能量化方式。</p><h3 id="系统设计目标二系统怎样做到高可用"><a class="markdownIt-Anchor" href="#系统设计目标二系统怎样做到高可用"></a> 系统设计目标（二）：系统怎样做到高可用？</h3><p>故障转移</p><ul><li>健康检查：心跳检测</li><li>选举：Paxos、Raft</li><li>负载均衡</li></ul><p>流量控制：</p><ul><li>超时与重试</li><li>限流</li><li>降级</li></ul><p>系统运维</p><ul><li>灰度发布</li><li>故障演练</li><li>CI/CD</li></ul><p>多活架构</p><h3 id="系统设计目标三如何让系统易于扩展"><a class="markdownIt-Anchor" href="#系统设计目标三如何让系统易于扩展"></a> 系统设计目标（三）：如何让系统易于扩展？</h3><p><strong>拆分首先考虑的维度是业务维度</strong></p><p>其次，当吞吐量达到单机瓶颈，针对存储做水平差费</p><h2 id="数据库篇"><a class="markdownIt-Anchor" href="#数据库篇"></a> 数据库篇</h2><h4 id="池化技术如何减少频繁创建数据库连接的性能损耗"><a class="markdownIt-Anchor" href="#池化技术如何减少频繁创建数据库连接的性能损耗"></a> 池化技术：如何减少频繁创建数据库连接的性能损耗？</h4><p>池化技术解决频繁创建连接、创建对象的成本</p><h3 id="数据库优化方案一查询请求增加时如何做主从分离"><a class="markdownIt-Anchor" href="#数据库优化方案一查询请求增加时如何做主从分离"></a> 数据库优化方案（一）：查询请求增加时，如何做主从分离？</h3><p>读写分离：写入时只写主库，在读数据时只读从库。通常采用一主多从架构。</p><p>读写分离的问题：<strong>主从同步的延迟</strong></p><p>读写分离的关键：</p><ul><li>主从复制</li><li>读写流量分发</li><li>代理：Cobar、Mycat</li><li>客户端：sharding-jdbc、TDDL</li></ul><h3 id="数据库优化方案二写入数据量增加时如何实现分库分表"><a class="markdownIt-Anchor" href="#数据库优化方案二写入数据量增加时如何实现分库分表"></a> 数据库优化方案（二）：写入数据量增加时，如何实现分库分表？</h3><p>垂直拆分：从业务维度，将表分为不同的库</p><p>水平拆分：分区 key 是关键。应使用合理策略，分库分表。如：hash 取 mod 法、范围划分</p><h3 id="发号器如何保证分库分表后-id-的全局唯一性"><a class="markdownIt-Anchor" href="#发号器如何保证分库分表后-id-的全局唯一性"></a> 发号器：如何保证分库分表后 ID 的全局唯一性？</h3><p>分布式 ID：UUID、Snowflake 算法</p><h3 id="nosql在高并发场景下数据库和-nosql-如何做到互补"><a class="markdownIt-Anchor" href="#nosql在高并发场景下数据库和-nosql-如何做到互补"></a> NoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？</h3><p>LSM 树：牺牲了一定的读性能来换取写入数据的高性能，Hbase、Cassandra、LevelDB 都是用这种算法作为存储的引擎。</p><p>数据首先会写入到一个叫做 MemTable 的内存结构中，在 MemTable 中数据是按照写入的 Key 来排序的。为了防止 MemTable 里面的数据因为机器掉电或者重启而丢失，一般会通过写 Write Ahead Log 的方式将数据备份在磁盘上。</p><p>MemTable 在累积到一定规模时，它会被刷新生成一个新的文件，我们把这个文件叫做 SSTable（Sorted String Table）。当 SSTable 达到一定数量时，我们会将这些 SSTable 合并，减少文件的数量，因为 SSTable 都是有序的，所以合并的速度也很快。</p><p>当从 LSM 树里面读数据时，我们首先从 MemTable 中查找数据，如果数据没有找到，再从 SSTable 中查找数据。因为存储的数据都是有序的，所以查找的效率是很高的，只是因为数据被拆分成多个 SSTable，所以读取的效率会低于 B+ 树索引。</p><h2 id="缓存篇"><a class="markdownIt-Anchor" href="#缓存篇"></a> 缓存篇</h2><h3 id="缓存数据库成为瓶颈后动态数据的查询要如何加速"><a class="markdownIt-Anchor" href="#缓存数据库成为瓶颈后动态数据的查询要如何加速"></a> 缓存：数据库成为瓶颈后，动态数据的查询要如何加速？</h3><p>缓存分类：静态缓存、进程内缓存、分布式缓存</p><h3 id="缓存的使用姿势一如何选择缓存的读写策略"><a class="markdownIt-Anchor" href="#缓存的使用姿势一如何选择缓存的读写策略"></a> 缓存的使用姿势（一）：如何选择缓存的读写策略？</h3><h3 id="cache-aside旁路缓存策略"><a class="markdownIt-Anchor" href="#cache-aside旁路缓存策略"></a> Cache Aside（旁路缓存）策略</h3><p>先写表，再写缓存，可能会导致缓存和数据库数据不一致</p><p>更新表，删除缓存 key；读数据时，从表中读取。</p><p><strong>读策略的步骤</strong></p><ul><li>从缓存中读取数据；</li><li>如果缓存命中，则直接返回数据；</li><li>如果缓存不命中，则从数据库中查询数据；</li><li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li></ul><p><strong>写策略的步骤</strong></p><ul><li>更新数据库中的记录；</li><li>删除缓存记录。</li></ul><p>Cache Aside 理论上还是有较小概率导致数据不一致。</p><p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</p><p><strong>如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</strong></p><ol><li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。</li></ol><h4 id="readwrite-through读穿-写穿策略"><a class="markdownIt-Anchor" href="#readwrite-through读穿-写穿策略"></a> Read/Write Through（读穿 / 写穿）策略</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210155.jpg" alt="" /></p><h3 id="write-back写回策略"><a class="markdownIt-Anchor" href="#write-back写回策略"></a> Write Back（写回）策略</h3><p>核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210420.jpg" alt="" /></p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210808210511.jpg" alt="" /></p><p>这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。</p><p>但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p><h3 id="缓存的使用姿势二缓存如何做到高可用"><a class="markdownIt-Anchor" href="#缓存的使用姿势二缓存如何做到高可用"></a> 缓存的使用姿势（二）：缓存如何做到高可用？</h3><p><strong>分布式缓存的高可用方案</strong></p><ul><li>客户端方案：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</li><li>代理层方案：客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</li><li>服务度方案：Redis Sentinel 方案</li></ul><h3 id="缓存的使用姿势三缓存穿透了怎么办"><a class="markdownIt-Anchor" href="#缓存的使用姿势三缓存穿透了怎么办"></a> 缓存的使用姿势（三）：缓存穿透了怎么办？</h3><p>缓存穿透解決方案：</p><ul><li>保存 null 值</li><li>布隆过滤器</li></ul><h2 id="消息队列篇"><a class="markdownIt-Anchor" href="#消息队列篇"></a> 消息队列篇</h2><h3 id="消息队列秒杀时如何处理每秒上万次的下单请求"><a class="markdownIt-Anchor" href="#消息队列秒杀时如何处理每秒上万次的下单请求"></a> 消息队列：秒杀时如何处理每秒上万次的下单请求？</h3><p>削峰、异步处理、系统解耦</p><h3 id="消息投递如何保证消息仅仅被消费一次"><a class="markdownIt-Anchor" href="#消息投递如何保证消息仅仅被消费一次"></a> 消息投递：如何保证消息仅仅被消费一次？</h3><h3 id="系统架构每秒-1-万次请求的系统要做服务化拆分吗"><a class="markdownIt-Anchor" href="#系统架构每秒-1-万次请求的系统要做服务化拆分吗"></a> 系统架构：每秒 1 万次请求的系统要做服务化拆分吗？</h3><p>系统中，使用的资源出现扩展性问题，尤其是数据库的连接数出现瓶颈；</p><p>大团队共同维护一套代码，带来研发效率的降低，和研发成本的提升；</p><p>系统部署成本越来越高。</p><h3 id="微服务架构微服务化后系统架构要如何改造"><a class="markdownIt-Anchor" href="#微服务架构微服务化后系统架构要如何改造"></a> 微服务架构：微服务化后，系统架构要如何改造？</h3><p>服务拆分时要遵循哪些原则？</p><p>服务的边界如何确定？服务的粒度是怎样呢？</p><p>在服务化之后，会遇到哪些问题呢？我们又将如何来解决？</p><h2 id="分布式服务篇"><a class="markdownIt-Anchor" href="#分布式服务篇"></a> 分布式服务篇</h2><h2 id="维护篇"><a class="markdownIt-Anchor" href="#维护篇"></a> 维护篇</h2><h3 id="给系统加上眼睛服务端监控要怎么做"><a class="markdownIt-Anchor" href="#给系统加上眼睛服务端监控要怎么做"></a> 给系统加上眼睛：服务端监控要怎么做？</h3><p>CPU、内存、磁盘、网络</p><p><strong>道路千万条，监控第一条，监控不到位，领导两行泪</strong></p><p>监控指标</p><p>采集方式</p><ul><li>Agent</li><li>埋点</li><li>日志</li></ul><p>处理和展示</p><h3 id="应用性能管理用户的使用体验应该如何监控"><a class="markdownIt-Anchor" href="#应用性能管理用户的使用体验应该如何监控"></a> 应用性能管理：用户的使用体验应该如何监控？</h3><h3 id="压力测试怎样设计全链路压力测试平台"><a class="markdownIt-Anchor" href="#压力测试怎样设计全链路压力测试平台"></a> 压力测试：怎样设计全链路压力测试平台？</h3><h3 id="配置管理成千上万的配置项要如何管理"><a class="markdownIt-Anchor" href="#配置管理成千上万的配置项要如何管理"></a> 配置管理：成千上万的配置项要如何管理？</h3><ul><li>配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；</li><li>配置中心可以提供配置变更通知的功能，可以实现配置的热更新；</li><li>配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到 99.999%，甚至会是 99.9999%。</li></ul><h2 id="实战篇"><a class="markdownIt-Anchor" href="#实战篇"></a> 实战篇</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高并发系统设计-40-问学习笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#高并发系统设计-40-问学习笔记&quot;&gt;&lt;/a&gt; 高并发系统设计 40 问学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;基础篇&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://dunwu.github.io/blog/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="架构" scheme="https://dunwu.github.io/blog/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章让你彻底掌握 Scala</title>
    <link href="https://dunwu.github.io/blog/coding/scala/"/>
    <id>https://dunwu.github.io/blog/coding/scala/</id>
    <published>2021-04-14T07:27:00.000Z</published>
    <updated>2021-08-26T15:33:01.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scala-入门"><a class="markdownIt-Anchor" href="#scala-入门"></a> Scala 入门</h1><blockquote><p>Scala 是大数据领域的热门语言，如：Akka、Kafka，所以，想要学习大数据顶级开源项目的源码，有必要具备一定的 Scala 基础。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1. 基本语法</a></li><li><a href="#2-%E6%B3%A8%E9%87%8A">2. 注释</a></li><li><a href="#3-%E5%8F%98%E9%87%8F">3. 变量</a><ul><li><a href="#31-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">3.1. 变量类型声明</a></li></ul></li><li><a href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">4. 数据类型</a></li><li><a href="#5-%E6%95%B0%E7%BB%84">5. 数组</a></li><li><a href="#6-%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">6. 逻辑控制语句</a><ul><li><a href="#61-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">6.1. 条件语句</a></li><li><a href="#62-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">6.2. 循环语句</a></li><li><a href="#63-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">6.3. 模式匹配</a></li></ul></li><li><a href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6">7. 运算符</a></li><li><a href="#8-%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0">8. 方法与函数</a></li><li><a href="#9-%E9%97%AD%E5%8C%85">9. 闭包</a></li><li><a href="#10-%E9%9B%86%E5%90%88">10. 集合</a><ul><li><a href="#101-%E8%BF%AD%E4%BB%A3%E5%99%A8">10.1. 迭代器</a></li></ul></li><li><a href="#11-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">11. 类和对象</a></li><li><a href="#12-trait">12. Trait</a></li><li><a href="#13-%E5%BC%82%E5%B8%B8">13. 异常</a></li><li><a href="#14-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">14. 输入输出</a><ul><li><a href="#141-%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">14.1. 读取用户输入</a></li><li><a href="#142-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">14.2. 读取文件内容</a></li></ul></li><li><a href="#15-%E5%8C%85">15. 包</a><ul><li><a href="#151-%E5%AE%9A%E4%B9%89%E5%8C%85">15.1. 定义包</a></li><li><a href="#152-%E5%BC%95%E7%94%A8">15.2. 引用</a></li><li><a href="#153-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">15.3. 访问修饰符</a></li></ul></li><li><a href="#16-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">16. 参考资料</a></li></ul><!-- /TOC --><h2 id="1-基本语法"><a class="markdownIt-Anchor" href="#1-基本语法"></a> 1. 基本语法</h2><p>Scala 基本语法需要注意以下几点：</p><ul><li><strong>区分大小写</strong> - Scala 是大小写敏感的。</li><li><strong>类名</strong> - 对于所有的类名的第一个字母要大写。示例：<code>class MyFirstScalaClass</code></li><li><strong>方法名称</strong> - 所有的方法名称的第一个字母用小写。示例：<code>def myMethodName()</code></li><li><strong>程序文件名</strong> - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。示例: 假设&quot;HelloWorld&quot;是对象的名称。那么该文件应保存为’HelloWorld.scala&quot;</li><li><strong><code>def main(args: Array[String])</code></strong> - Scala 程序从 <code>main()</code> 方法开始处理，这是每一个 Scala 程序的强制程序入口部分。</li><li>一行中只有空格或者带有注释，Scala 会认为其是空行，会忽略它。标记可以被空格或者注释来分割。</li><li>Scala 是面向行的语言，语句可以用分号（;）结束或换行符。</li></ul><h2 id="2-注释"><a class="markdownIt-Anchor" href="#2-注释"></a> 2. 注释</h2><p>Scala 类似 Java 支持单行和多行注释。</p><p>【示例】单行和多行注释</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">   * 以下程序将输出'Hello World!'</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"Hello, world!"</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-变量"><a class="markdownIt-Anchor" href="#3-变量"></a> 3. 变量</h2><p>在 Scala 中，使用关键词 <code>var</code> 声明变量，使用关键词 <code>val</code> 声明常量。</p><p>【示例】声明变量</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">"Foo"</span></span><br><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">"Too"</span></span><br></pre></td></tr></table></figure><p>【示例】声明常量</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal : <span class="type">String</span> = <span class="string">"Foo"</span></span><br></pre></td></tr></table></figure><h3 id="31-变量类型声明"><a class="markdownIt-Anchor" href="#31-变量类型声明"></a> 3.1. 变量类型声明</h3><p>变量的类型在变量名之后等号之前声明。定义变量的类型的语法格式如下：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br><span class="line"><span class="comment">// 声明常量类型</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">VariableName</span> : <span class="type">DataType</span> [=  <span class="type">Initial</span> <span class="type">Value</span>]</span><br></pre></td></tr></table></figure><p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">val</span> myVal = <span class="string">"Hello, Scala!"</span>;</span><br><span class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="4-数据类型"><a class="markdownIt-Anchor" href="#4-数据类型"></a> 4. 数据类型</h2><p>Scala 与 Java 有着相同的数据类型：</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Byte</td><td style="text-align:left">8 位有符号补码整数。数值区间为 -128 到 127</td></tr><tr><td style="text-align:left">Short</td><td style="text-align:left">16 位有符号补码整数。数值区间为 -32768 到 32767</td></tr><tr><td style="text-align:left">Int</td><td style="text-align:left">32 位有符号补码整数。数值区间为 -2147483648 到 2147483647</td></tr><tr><td style="text-align:left">Long</td><td style="text-align:left">64 位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807</td></tr><tr><td style="text-align:left">Float</td><td style="text-align:left">32 位, IEEE 754 标准的单精度浮点数</td></tr><tr><td style="text-align:left">Double</td><td style="text-align:left">64 位 IEEE 754 标准的双精度浮点数</td></tr><tr><td style="text-align:left">Char</td><td style="text-align:left">16 位无符号 Unicode 字符, 区间值为 U+0000 到 U+FFFF</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">字符序列</td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:left">true 或 false</td></tr><tr><td style="text-align:left">Unit</td><td style="text-align:left">表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()。</td></tr><tr><td style="text-align:left">Null</td><td style="text-align:left">null 或空引用</td></tr><tr><td style="text-align:left">Nothing</td><td style="text-align:left">Nothing 类型在 Scala 的类层级的最底端；它是任何其他类型的子类型。</td></tr><tr><td style="text-align:left">Any</td><td style="text-align:left">Any 是所有其他类的超类</td></tr><tr><td style="text-align:left">AnyRef</td><td style="text-align:left">AnyRef 类是 Scala 里所有引用类(reference class)的基类</td></tr></tbody></table><p>上表中列出的数据类型都是<strong>对象</strong>，也就是说 scala 没有 java 中的原生类型。在 scala 是可以对数字等基础类型调用方法的。</p><h2 id="5-数组"><a class="markdownIt-Anchor" href="#5-数组"></a> 5. 数组</h2><p>Scala 数组声明的语法格式：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> z:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="6-逻辑控制语句"><a class="markdownIt-Anchor" href="#6-逻辑控制语句"></a> 6. 逻辑控制语句</h2><h3 id="61-条件语句"><a class="markdownIt-Anchor" href="#61-条件语句"></a> 6.1. 条件语句</h3><p>【示例】条件语句</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 10"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 20"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">      println(<span class="string">"X 的值为 30"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">"无法判断 X 的值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="62-循环语句"><a class="markdownIt-Anchor" href="#62-循环语句"></a> 6.2. 循环语句</h3><p>和 Java 一样，Scala 支持 <code>while</code>、<code>do ... while</code>、<code>for</code> 三种循环语句。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">      println(<span class="string">"Value of a: "</span> + a);</span><br><span class="line">      a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>scala 不支持 <code>break</code> 和 <code>continue</code></strong>。但是，可以通过 <code>Breaks</code> 对象来进行循环控制。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">val</span> numList1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">val</span> numList2 = <span class="type">List</span>(<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> outer = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line">    <span class="keyword">val</span> inner = <span class="keyword">new</span> <span class="type">Breaks</span>;</span><br><span class="line"></span><br><span class="line">    outer.breakable &#123;</span><br><span class="line">      <span class="keyword">for</span> (a &lt;- numList1) &#123;</span><br><span class="line">        println(<span class="string">"Value of a: "</span> + a);</span><br><span class="line">        inner.breakable &#123;</span><br><span class="line">          <span class="keyword">for</span> (b &lt;- numList2) &#123;</span><br><span class="line">            println(<span class="string">"Value of b: "</span> + b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">12</span>) &#123;</span><br><span class="line">              inner.<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// 内嵌循环中断</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="comment">// 外部循环中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="63-模式匹配"><a class="markdownIt-Anchor" href="#63-模式匹配"></a> 6.3. 模式匹配</h3><p>scala 的 <code>match</code> 对应 Java 里的 <code>switch</code>，但是写在选择器表达式之后。即： <strong>选择器 match {备选项}。</strong></p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @author peng.zhang</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MatchDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(matchTest(<span class="string">"two"</span>))</span><br><span class="line">    println(matchTest(<span class="string">"test"</span>))</span><br><span class="line">    println(matchTest(<span class="number">1</span>))</span><br><span class="line">    println(matchTest(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">matchTest</span></span>(x: <span class="type">Any</span>): <span class="type">Any</span> = x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>      =&gt; <span class="string">"one"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"two"</span>  =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> y: <span class="type">Int</span> =&gt; <span class="string">"scala.Int"</span></span><br><span class="line">    <span class="keyword">case</span> _      =&gt; <span class="string">"many"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-运算符"><a class="markdownIt-Anchor" href="#7-运算符"></a> 7. 运算符</h2><p>Scala 含有丰富的内置运算符，包括以下几种类型：</p><ul><li>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></li><li>关系运算符：<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li><li>位运算符：<code>~</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code> （无符号右移）</li><li>赋值运算符：<code>=</code></li></ul><h2 id="8-方法与函数"><a class="markdownIt-Anchor" href="#8-方法与函数"></a> 8. 方法与函数</h2><p>Scala 有方法与函数，二者在语义上的区别很小。</p><p>Scala 中的方法跟 Java 的类似，方法是组成类的一部分。</p><p>Scala 中的函数则是一个完整的对象，Scala 中的函数其实就是继承了 Trait 的类的对象。</p><p>Scala 中使用 <code>val</code> 语句可以定义函数，<code>def</code> 语句定义方法。</p><p>【示例】</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">Int</span>) = x + <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> f = (x: <span class="type">Int</span>) =&gt; x + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-闭包"><a class="markdownIt-Anchor" href="#9-闭包"></a> 9. 闭包</h2><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p><p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p><p>如下面这段匿名的函数：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * <span class="number">10</span></span><br></pre></td></tr></table></figure><p>函数体内有一个变量 i，它作为函数的一个参数。如下面的另一段代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure><p>在 multiplier 中有两个变量：i 和 factor。其中的一个 i 是函数的形式参数，在 multiplier 函数被调用时，i 被赋予一个新的值。然而，factor 不是形式参数，而是自由变量，考虑下面代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br></pre></td></tr></table></figure><p>这里我们引入一个自由变量 factor，这个变量定义在函数外面。</p><p>这样定义的函数变量 multiplier 成为一个&quot;闭包&quot;，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ClosureDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"muliplier(1) value = "</span> + multiplier(<span class="number">1</span>))</span><br><span class="line">    println(<span class="string">"muliplier(2) value = "</span> + multiplier(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> factor = <span class="number">3</span></span><br><span class="line">  <span class="keyword">val</span> multiplier = (i: <span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-集合"><a class="markdownIt-Anchor" href="#10-集合"></a> 10. 集合</h2><p>Scala 集合支持 List、Set、Map、元祖、Option。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义整型 List</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Set</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Map</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Map</span>(<span class="string">"one"</span> -&gt; <span class="number">1</span>, <span class="string">"two"</span> -&gt; <span class="number">2</span>, <span class="string">"three"</span> -&gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个不同类型元素的元组</span></span><br><span class="line"><span class="keyword">val</span> x = (<span class="number">10</span>, <span class="string">"Runoob"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Option</span></span><br><span class="line"><span class="keyword">val</span> x:<span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="101-迭代器"><a class="markdownIt-Anchor" href="#101-迭代器"></a> 10.1. 迭代器</h3><p>迭代器 it 的两个基本操作是 <strong>next</strong> 和 <strong>hasNext</strong>。</p><p>调用 <strong>it.next()</strong> 会返回迭代器的下一个元素，并且更新迭代器的状态。</p><p>调用 <strong>it.hasNext()</strong> 用于检测集合中是否还有元素。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">      <span class="keyword">val</span> it = <span class="type">Iterator</span>(<span class="string">"Baidu"</span>, <span class="string">"Google"</span>, <span class="string">"Runoob"</span>, <span class="string">"Taobao"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (it.hasNext)&#123;</span><br><span class="line">         println(it.next())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-类和对象"><a class="markdownIt-Anchor" href="#11-类和对象"></a> 11. 类和对象</h2><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">val xc: <span class="type">Int</span>, val yc: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    println(<span class="string">"x 的坐标点 : "</span> + x);</span><br><span class="line">    println(<span class="string">"y 的坐标点 : "</span> + y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">override val xc: <span class="type">Int</span>, override val yc: <span class="type">Int</span>, val zc: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Point</span>(<span class="params">xc, yc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z: <span class="type">Int</span> = zc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, dz: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = x + dx</span><br><span class="line">    y = y + dy</span><br><span class="line">    z = z + dz</span><br><span class="line">    println(<span class="string">"x 的坐标点 : "</span> + x);</span><br><span class="line">    println(<span class="string">"y 的坐标点 : "</span> + y);</span><br><span class="line">    println(<span class="string">"z 的坐标点 : "</span> + z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> loc = <span class="keyword">new</span> <span class="type">Location</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移到一个新的位置</span></span><br><span class="line">    loc.move(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-trait"><a class="markdownIt-Anchor" href="#12-trait"></a> 12. Trait</h2><p>Scala Trait(特征) 相当于 Java 的接口，实际上它比接口还功能强大。</p><p>与接口不同的是，它还可以定义属性和方法的实现。</p><p>一般情况下 Scala 的类只能够继承单一父类，但是如果是 Trait(特征) 的话就可以继承多个，从结果来看就是实现了多重继承。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isNotEqual</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = !isEqual(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">xc: <span class="type">Int</span>, yc: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Equal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> = xc</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> = yc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEqual</span></span>(obj: <span class="type">Any</span>) =</span><br><span class="line">    obj.isInstanceOf[<span class="type">Point</span>] &amp;&amp;</span><br><span class="line">      obj.asInstanceOf[<span class="type">Point</span>].x == x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Point</span>(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    println(p1.isNotEqual(p2))</span><br><span class="line">    println(p1.isNotEqual(p3))</span><br><span class="line">    println(p1.isNotEqual(<span class="number">2</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-异常"><a class="markdownIt-Anchor" href="#13-异常"></a> 13. 异常</h2><p>Scala 抛出异常的方法和 Java 一样，使用 <code>throw</code> 关键词。</p><p>【示例】抛出异常</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>【示例】捕获异常</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileNotFoundException</span>, <span class="type">FileReader</span>, <span class="type">IOException</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">"input.txt"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">"Missing file exception"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; &#123;</span><br><span class="line">        println(<span class="string">"IO Exception"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      println(<span class="string">"Exiting finally..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-输入输出"><a class="markdownIt-Anchor" href="#14-输入输出"></a> 14. 输入输出</h2><h3 id="141-读取用户输入"><a class="markdownIt-Anchor" href="#141-读取用户输入"></a> 14.1. 读取用户输入</h3><p>使用 <code>scala.io.StdIn.readLine()</code> 方法读取用户输入</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StdInDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    print(<span class="string">"请输入内容: "</span>)</span><br><span class="line">    <span class="keyword">val</span> line = <span class="type">StdIn</span>.readLine()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"你输入的是: "</span> + line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-读取文件内容"><a class="markdownIt-Anchor" href="#142-读取文件内容"></a> 14.2. 读取文件内容</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SourceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    println(<span class="string">"文件内容为:"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">"test.txt"</span>).foreach &#123;</span><br><span class="line">      print</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-包"><a class="markdownIt-Anchor" href="#15-包"></a> 15. 包</h2><h3 id="151-定义包"><a class="markdownIt-Anchor" href="#151-定义包"></a> 15.1. 定义包</h3><p>Scala 使用 <code>package</code> 关键字定义包，在 Scala 将代码定义到某个包中有两种方式：</p><p>第一种方法和 Java 一样，在文件的头定义包名，这种方法就后续所有代码都放在该包中。 比如：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br></pre></td></tr></table></figure><p>第二种方法有些类似 C#，如：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="152-引用"><a class="markdownIt-Anchor" href="#152-引用"></a> 15.2. 引用</h3><p>Scala 使用 <code>import</code> 关键字引用包。</p><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color  <span class="comment">// 引入Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt._  <span class="comment">// 引入包内所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span></span>(evt: event.ActionEvent) &#123; <span class="comment">// java.awt.event.ActionEvent</span></span><br><span class="line">  ...  <span class="comment">// 因为引入了java.awt，所以可以省去前面的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>import 语句可以出现在任何地方，而不是只能在文件顶部。import 的效果从开始延伸到语句块的结束。这可以大幅减少名称冲突的可能性。</p><p>如果想要引入包中的几个成员，可以使用 selector（选取器）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.&#123;Color, Font&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="function"><span class="params">HashMap</span> =&gt;</span> JavaHashMap&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏成员</span></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="function"><span class="params">HashMap</span> =&gt;</span> _, _&#125; <span class="comment">// 引入了util包的所有成员，但是HashMap被隐藏了</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意：**默认情况下，Scala 总会引入 java.lang._ 、 scala._ 和 Predef._，这里也能解释，为什么以 scala 开头的包，在使用时都是省去 scala.的。</p></blockquote><h3 id="153-访问修饰符"><a class="markdownIt-Anchor" href="#153-访问修饰符"></a> 15.3. 访问修饰符</h3><p>Scala 访问修饰符基本和 Java 的一样，分别有：private，protected，public。</p><p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p><p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;</span><br><span class="line">      println(<span class="string">"f"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span> </span>&#123;</span><br><span class="line">      f() <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-参考资料"><a class="markdownIt-Anchor" href="#16-参考资料"></a> 16. 参考资料</h2><ul><li><a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala 官网</a></li><li><a href="https://www.runoob.com/scala/scala-tutorial.html" target="_blank" rel="noopener">Scala 菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scala-入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#scala-入门&quot;&gt;&lt;/a&gt; Scala 入门&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Scala 是大数据领域的热门语言，如：Akka、Kafka，所以，想要学习大数据
      
    
    </summary>
    
    
      <category term="编程" scheme="https://dunwu.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="https://dunwu.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="scala" scheme="https://dunwu.github.io/blog/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>效率提升方法论</title>
    <link href="https://dunwu.github.io/blog/efficiency/methodology/"/>
    <id>https://dunwu.github.io/blog/efficiency/methodology/</id>
    <published>2020-02-10T08:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="效率提升方法论"><a class="markdownIt-Anchor" href="#效率提升方法论"></a> 效率提升方法论</h1><p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p><p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p><p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p><blockquote><p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p><p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p><p>——莎士比亚</p></blockquote><h2 id="5w2h"><a class="markdownIt-Anchor" href="#5w2h"></a> 5W2H</h2><p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p><p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p><p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210161837.png" alt="5W2H" /></p><ul><li><p><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</p></li><li><p><strong>what</strong> - 是什么？目的是什么？作什么工作？</p></li><li><p><strong>where</strong> - 何处？在哪里做？从哪里入手？</p></li><li><p><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</p></li><li><p><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</p></li><li><p><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</p></li><li><p><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p></li></ul><h2 id="四象限原则"><a class="markdownIt-Anchor" href="#四象限原则"></a> 四象限原则</h2><p><strong>四象限原则是一种时间管理方式</strong>。</p><p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p><p>事情、任务太多，时间太少，分身乏术。</p><p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210173335.png" alt="img" /></p><ul><li><p><strong>第一象限（重要而紧急</strong>）</p><ul><li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li><li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li><li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li></ul></li><li><p><strong>第二象限（重要但不紧急）</strong></p><ul><li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li><li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li><li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li></ul></li><li><p><strong>第三象限（紧急但不重要）</strong></p><ul><li>案例：电话、会议、突发的访客都属于这一类。</li><li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li></ul></li><li><p><strong>第四象限（不紧急也不重要）</strong></p><ul><li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li><li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;效率提升方法论&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#效率提升方法论&quot;&gt;&lt;/a&gt; 效率提升方法论&lt;/h1&gt;
&lt;p&gt;在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。&lt;/p&gt;
&lt;p&gt;做任何事，如果有了
      
    
    </summary>
    
    
      <category term="效率提升" scheme="https://dunwu.github.io/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
      <category term="方法论" scheme="https://dunwu.github.io/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="效率提升" scheme="https://dunwu.github.io/blog/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
      <category term="方法论" scheme="https://dunwu.github.io/blog/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="5W2H" scheme="https://dunwu.github.io/blog/tags/5W2H/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之 VPN</title>
    <link href="https://dunwu.github.io/blog/network/vpn/"/>
    <id>https://dunwu.github.io/blog/network/vpn/</id>
    <published>2020-02-03T02:30:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信之-vpn"><a class="markdownIt-Anchor" href="#网络通信之-vpn"></a> 网络通信之 VPN</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203095528.png" alt="img" /></p><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#vpn-%E7%9A%84%E4%BD%9C%E7%94%A8">VPN 的作用</a><ul><li><a href="#%E9%9A%90%E8%97%8F-ip-%E5%92%8C%E4%BD%8D%E7%BD%AE">隐藏 IP 和位置</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E5%8A%A0%E5%AF%86">通信加密</a></li><li><a href="#%E7%BF%BB%E5%A2%99">翻墙</a></li><li><a href="#%E9%81%BF%E5%85%8D%E8%A2%AB%E7%9B%91%E5%90%AC">避免被监听</a></li></ul></li><li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a></li><li><a href="#vpn-%E5%8D%8F%E8%AE%AE">VPN 协议</a></li><li><a href="#vpn-%E6%9C%8D%E5%8A%A1">VPN 服务</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN 可通过服务器、硬件、软件等多种方式实现。</p><p>VPN 属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。<br />在传统的企业网络配置中，要进行远程访问，传统的方法是租用 DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。<br />让外地员工访问到内网资源，利用 VPN 的解决方法就是在内网中架设一台 VPN 服务器。外地员工在当地连上互联网后，通过互联网连接 VPN 服务器，然后通过 VPN 服务器进入企业内网。为了保证数据安全，VPN 服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上 VPN 使用的是互联网上的公用链路，因此 VPN 称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了 VPN 技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用 VPN 访问内网资源，这就是 VPN 在企业中应用得如此广泛的原因。</p><h2 id="vpn-的作用"><a class="markdownIt-Anchor" href="#vpn-的作用"></a> VPN 的作用</h2><h3 id="隐藏-ip-和位置"><a class="markdownIt-Anchor" href="#隐藏-ip-和位置"></a> 隐藏 IP 和位置</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100404.png" alt="img" /></p><p>VPN 可以隐藏使用者的 IP 地址和位置。</p><p>使用 VPN 的最常见原因之一是屏蔽您的真实 IP 地址。</p><p>您的 IP 地址是由 ISP 分配的唯一数字地址。 您在线上所做的所有事情都链接到您的 IP 地址，因此可以用来将您与在线活动进行匹配。 大多数网站记录其访问者的 IP 地址。</p><p>广告商还可以使用您的 IP 地址，根据您的身份和浏览历史为您提供有针对性的广告。</p><p>连接到 VPN 服务器时，您将使用该 VPN 服务器的 IP 地址。 您访问的任何网站都会看到 VPN 服务器的 IP 地址，而不是您自己的。</p><p>您将能够绕过 IP 地址阻止并浏览网站，而不会将您的活动作为一个个人追溯到您。</p><h3 id="通信加密"><a class="markdownIt-Anchor" href="#通信加密"></a> 通信加密</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100543.png" alt="img" /></p><p>使用 VPN 时，可以对信息进行加密，使得密码，电子邮件，照片，银行数据和其他敏感信息不会被拦截。</p><p>如果在公共场所使用公共 WiFi 连接网络时，敏感数据有被盗的风险。黑客可以利用开放和未加密的网络来窃取重要数据，例如您的密码，电子邮件，照片，银行数据和其他敏感信息。</p><p>VPN 可以加密信息，使黑客更难以拦截和窃取数据。</p><h3 id="翻墙"><a class="markdownIt-Anchor" href="#翻墙"></a> 翻墙</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100706.png" alt="img" /></p><p>轻松解除对 Facebook 和 Twitter，Skype，YouTube 和 Gmail 等网站和服务的阻止。 即使您被告知您所在的国家/地区不可用它，或者您所在的学校或办公室网络限制访问，也可以获取所需的东西。</p><p>某些服务（例如 Netflix 或 BBC iPlayer）会根据您访问的国家/地区限制访问内容。使用 VPN 可以绕过这些地理限制并解锁“隐藏”内容的唯一可靠方法。</p><h3 id="避免被监听"><a class="markdownIt-Anchor" href="#避免被监听"></a> 避免被监听</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203100933.png" alt="img" /></p><p>使用 VPN 可以向政府、ISP、黑客隐藏通信信息。</p><p>您的 Internet 服务提供商（ISP）可以看到您访问的所有网站，并且几乎可以肯定会记录该信息。</p><p>在某些国家/地区，ISP 需要长时间收集和存储用户数据，并且政府能够访问，存储和搜索该信息。</p><p>在美国，英国，澳大利亚和欧洲大部分地区就是这种情况，仅举几例。</p><p>由于 VPN 会加密从设备到 VPN 服务器的互联网流量，因此您的 ISP 或任何其他第三方将无法监视您的在线活动。</p><p>要了解有关监视技术和全球大规模监视问题的更多信息，请访问 EFF 和 Privacy International。 您还可以在此处找到全球监视披露的更新列表。</p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>VPN 会在您的设备和私人服务器之间建立私人和加密的互联网连接。 这意味着您的数据无法被 ISP 或任何其他第三方读取或理解。 然后，私有服务器将您的流量发送到您要访问的网站或服务上。</p><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102422.png" alt="img" /></p><p>VPN 的基本处理过程如下：</p><ol><li>要保护主机发送明文信息到其他 VPN 设备。</li><li>VPN 设备根据网络管理员设置的规则，确定是对数据进行加密还是直接传输。</li><li>对需要加密的数据，VPN 设备将其整个数据包（包括要传输的数据、源 IP 地址和目的 lP 地址）进行加密并附上数据签名，加上新的数据报头（包括目的地 VPN 设备需要的安全信息和一些初始化参数）重新封装。</li><li>将封装后的数据包通过隧道在公共网络上传输。</li><li>数据包到达目的 VPN 设备后，将其解封，核对数字签名无误后，对数据包解密。</li></ol><h2 id="vpn-协议"><a class="markdownIt-Anchor" href="#vpn-协议"></a> VPN 协议</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200203102656.png" alt="img" /></p><ul><li><p>OpenVPN</p></li><li><p>IKEv2 / IPSec</p></li><li><p>SSTP</p></li><li><p>PPTP</p></li><li><p>Wireguard</p></li></ul><h2 id="vpn-服务"><a class="markdownIt-Anchor" href="#vpn-服务"></a> VPN 服务</h2><p>你可以选择付费 VPN 或自行搭建 VPN。</p><p>VPN 服务商：</p><ul><li><a href="https://go.nordvpn.net/aff_c?offer_id=15&amp;aff_id=22023&amp;url_id=902" target="_blank" rel="noopener">NordVPN</a></li><li><a href="https://www.linkev.com/?a_fid=techacro" target="_blank" rel="noopener">ExpressVPN</a></li><li><a href="https://cybertool.co/tchacrobat_fs_izci9mc6y" target="_blank" rel="noopener">CyberGhostVPN</a></li><li><a href="https://click.tunnelbear.com/aff_c?offer_id=36&amp;aff_id=7306" target="_blank" rel="noopener">TunnelBear</a></li><li><a href="https://www.ipvanish.com/" target="_blank" rel="noopener">IPVanish</a></li></ul><p>开源 VPN：</p><ul><li><a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a></li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">百度百科 - VPN</a></li><li><a href="https://www.expressvpn.com/what-is-vpn" target="_blank" rel="noopener">What is a VPN</a></li><li><a href="https://www.youtube.com/watch?v=_wQTRMBAvzg" target="_blank" rel="noopener">What is a VPN and How Does it Work</a></li><li><a href="https://www.top10vpn.com/guides/what-is-a-vpn/" target="_blank" rel="noopener">What Is a VPN (Virtual Private Network) and How Does It Work?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信之-vpn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络通信之-vpn&quot;&gt;&lt;/a&gt; 网络通信之 VPN&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="VPN" scheme="https://dunwu.github.io/blog/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>网络通信知识点面经</title>
    <link href="https://dunwu.github.io/blog/network/network-interview/"/>
    <id>https://dunwu.github.io/blog/network/network-interview/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信知识点面经"><a class="markdownIt-Anchor" href="#网络通信知识点面经"></a> 网络通信知识点面经</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p>如果你不是从事于通信领域，面试时问及计算机网络的知识，一般也就限定在：HTTP（含 HTTPS、Cookie、Session）、TCP、UDP、Socket 这些</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E7%BB%BC%E5%90%88">1. 综合</a><ul><li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82">1.1. 计算机网络如何分层？</a></li></ul></li><li><a href="#2-http">2. HTTP</a></li><li><a href="#3-dns">3. DNS</a></li><li><a href="#4-tcpudp">4. TCP/UDP</a><ul><li><a href="#41-%E4%BB%80%E4%B9%88%E6%98%AF-tcp">4.1. 什么是 TCP？</a></li><li><a href="#42-tcp-%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88">4.2. TCP 的特性是什么？</a></li><li><a href="#43-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">4.3. TCP 三次握手</a></li><li><a href="#44-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.4. TCP 四次挥手</a></li><li><a href="#45-tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">4.5. TCP 滑动窗口</a></li><li><a href="#46-tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4.6. TCP 重传机制</a></li></ul></li></ul><!-- /TOC --><h2 id="1-综合"><a class="markdownIt-Anchor" href="#1-综合"></a> 1. 综合</h2><h3 id="11-计算机网络如何分层"><a class="markdownIt-Anchor" href="#11-计算机网络如何分层"></a> 1.1. 计算机网络如何分层？</h3><blockquote><p>❓ 问题：计算机网络如何分层？各层的作用是什么？各层的主要协议、设备分别是什么？</p><p>这是学习计算机网络知识宏观层面必须要了解的核心点。知道了这些，对于网络的体系结构就基本上了解了。</p></blockquote><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/network-layers.png"/></div>计算机网络分层一般有三种划分体系：OSI 分层；五层协议分层；TCP/IP 协议分层。<ul><li>OSI 的七层体系结构概念清楚，理论完整，但是比较复杂且不实用，所以并不流行。</li><li>五层协议分层是一种折中方案，在现实中更为流行。</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/overview/网络分层架构图.png"/></div>**物理层**<blockquote><p>物理层（Physical Layer）只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><p>扩展阅读：<a href="network-physical.md">计算机网络之物理层</a></p></blockquote><ul><li>关键词：调制、解调、数字信号、模拟信号、通信媒介、信道复用</li><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul><p><strong>数据链路层</strong></p><blockquote><p>网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，数据链路层（Data Link Layer）就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><p>扩展阅读：<a href="network-data-link.md">计算机网络之数据链路层</a></p></blockquote><ul><li>关键词：点对点信道、广播信道、<code>PPP</code>、<code>CSMA/CD</code>、局域网、以太网、<code>MAC</code>、适配器、集线器、网桥、交换机</li><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul><p><strong>网络层</strong></p><blockquote><p>网络层（network layer）为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>IP</code>、<code>ICMP</code>、<code>ARP</code>、路由</li><li>主要协议：<code>IP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul><p><strong>传输层</strong></p><blockquote><p>传输层（transport layer）为两台主机中进程间的通信提供通用的数据传输服务。</p><p>扩展阅读：<a href="network-network.md">计算机网络之网络层</a></p></blockquote><ul><li>关键词：<code>UDP</code>、<code>TCP</code>、滑动窗口、拥塞控制、三次握手</li><li>主要协议：<code>TCP</code>、<code>UDP</code>。</li><li>数据单元：报文段（segment）或用户数据报。</li></ul><p><sub>~**会话层**~</sub></p><blockquote><p>~~会话层（Session Layer）不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。~~</p></blockquote><p><sub>~**表示层**~</sub></p><blockquote><p>~~表示层（Presentation Layer）是为在应用过程之间传送的信息提供表示方法的服务，它关心的只是发出信息的语法与语义。表示层要完成某些特定的功能，主要有不同数据编码格式的转换，提供数据压缩、解压缩服务，对数据进行加密、解密。~~</p></blockquote><p><strong>应用层</strong></p><blockquote><p>应用层（application layer）通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。</p><p>扩展阅读：<a href="network-application.md">计算机网络之应用层</a></p></blockquote><ul><li>关键词：<code>HTTP</code>、<code>DNS</code>、<code>FTP</code>、<code>TELNET</code>、<code>DHCP</code></li><li>主要协议：<code>HTTP</code>、<code>DNS</code>、<code>SMTP</code>、<code>Telnet</code>、<code>FTP</code>、<code>SNMP</code> 等。</li><li>数据单元：报文（message）。</li></ul><h2 id="2-http"><a class="markdownIt-Anchor" href="#2-http"></a> 2. HTTP</h2><blockquote><p>扩展阅读：<a href="http.md">超文本传输协议 HTTP</a></p></blockquote><h2 id="3-dns"><a class="markdownIt-Anchor" href="#3-dns"></a> 3. DNS</h2><blockquote><p>扩展阅读：<a href="dns.md">域名系统 DNS</a></p></blockquote><h2 id="4-tcpudp"><a class="markdownIt-Anchor" href="#4-tcpudp"></a> 4. TCP/UDP</h2><blockquote><p>扩展阅读：<a href="tcp.md">传输控制协议 TCP</a>，<a href="udp.md">用户数据报协议 UDP</a></p></blockquote><h3 id="41-什么是-tcp"><a class="markdownIt-Anchor" href="#41-什么是-tcp"></a> 4.1. 什么是 TCP？</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。</p><h3 id="42-tcp-的特性是什么"><a class="markdownIt-Anchor" href="#42-tcp-的特性是什么"></a> 4.2. TCP 的特性是什么？</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="43-tcp-三次握手"><a class="markdownIt-Anchor" href="#43-tcp-三次握手"></a> 4.3. TCP 三次握手</h3><blockquote><p>❓ 问题：三次握手有什么用？什么是三次握手？为什么需要三次握手？</p></blockquote><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div>如上图所示，三次握手流程如下：<ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="44-tcp-四次挥手"><a class="markdownIt-Anchor" href="#44-tcp-四次挥手"></a> 4.4. TCP 四次挥手</h3><blockquote><p>❓ 问题：四次挥手有什么用？什么是四次挥手？为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p></blockquote><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div>1. 第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。2. 第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。3. 第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。4. 第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。<p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h3 id="45-tcp-滑动窗口"><a class="markdownIt-Anchor" href="#45-tcp-滑动窗口"></a> 4.5. TCP 滑动窗口</h3><blockquote><p>❓ 问题：什么是滑动窗口？滑动窗口原理是什么？</p></blockquote><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div>1. 已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。2. 已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 \~ 45 字节为第 2 类。3. 未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 \~ 51 字节为第 3 类。4. 未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。<h3 id="46-tcp-重传机制"><a class="markdownIt-Anchor" href="#46-tcp-重传机制"></a> 4.6. TCP 重传机制</h3><blockquote><p>❓ 问题：为什么需要重传机制？TCP 有哪些重传机制，原理是什么？</p></blockquote><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><p>（1）超时重传机制</p><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><p>（2）快速重传机制</p><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信知识点面经&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络通信知识点面经&quot;&gt;&lt;/a&gt; 网络通信知识点面经&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="application" scheme="https://dunwu.github.io/blog/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 TCP</title>
    <link href="https://dunwu.github.io/blog/network/tcp/"/>
    <id>https://dunwu.github.io/blog/network/tcp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络协议之-tcp"><a class="markdownIt-Anchor" href="#网络协议之-tcp"></a> 网络协议之 TCP</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-tcp">什么是 TCP</a></li><li><a href="#tcp-%E7%9A%84%E7%89%B9%E6%80%A7">TCP 的特性</a></li><li><a href="#tcp-%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">TCP 的适用场景</a></li><li><a href="#tcp-%E6%8A%A5%E6%96%87">TCP 报文</a></li></ul></li><li><a href="#tcp-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B">TCP 通信流程</a><ul><li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li><li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li></ul></li><li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li><li><a href="#tcp-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">TCP 重传机制</a><ul><li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">超时重传机制</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">快速重传机制</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="什么是-tcp"><a class="markdownIt-Anchor" href="#什么是-tcp"></a> 什么是 TCP</h3><p><strong>TCP（Transmission Control Protocol），即传输控制协议，它是一种<code>面向连接的</code>、<code>可靠的</code>、<code>基于字节流的</code>传输层通信协议</strong>。TCP 由 RFC 793 定义。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559263786555.png"/></div><h3 id="tcp-的特性"><a class="markdownIt-Anchor" href="#tcp-的特性"></a> TCP 的特性</h3><ul><li><code>面向连接的</code> - 面向连接是指 TCP 需要通过三次握手、四次挥手原则建立和断开双向连接。</li><li><code>可靠的</code> - 可靠是指 TCP 传输的数据包保证以原始顺序到达目的地，且数据包不被损坏。为了实现这点，TCP 通过以下技术来保证：<ul><li>数据包的序列号和校验码</li><li>确认包和自动重传<ul><li>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。</li><li>TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</li></ul></li></ul></li><li><code>基于字节流的</code><ul><li>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li><li>在 TCP 建立连接前两次握手的 SYN 报文中选项字段的 MSS 值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送；否则通过滑动窗口来控制通信双发的数据。</li></ul></li></ul><h3 id="tcp-的适用场景"><a class="markdownIt-Anchor" href="#tcp-的适用场景"></a> TCP 的适用场景</h3><p>基于以上特性，为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。但要注意的是，在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，这时可以考虑在适用情况下切换到 UDP。</p><p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p><p>以下情况使用 TCP 代替 UDP：</p><ul><li>你需要数据完好无损。</li><li>你想对网络吞吐量自动进行最佳评估。</li></ul><h3 id="tcp-报文"><a class="markdownIt-Anchor" href="#tcp-报文"></a> TCP 报文</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264511812.png"/></div><p>报文字段不一一阐述，重点关注以下几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264593860.png"/></div><h2 id="tcp-通信流程"><a class="markdownIt-Anchor" href="#tcp-通信流程"></a> TCP 通信流程</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559264679371.png"/></div><p>TCP 完整的通信分为三块：</p><ol><li>三次握手建立连接</li><li>数据传输</li><li>四次挥手端口连接</li></ol><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>（1）三次握手有什么用？</p><ul><li>三次握手负责建立 TCP 双向连接。</li></ul><p>（2）什么是三次握手？</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/三次握手.gif!zp"/></div><p>如上图所示，三次握手流程如下：</p><ol><li>第一次握手 - 客户端向服务端发送带有 SYN 标志的数据包。</li><li>第二次握手 - 服务端向客户端发送带有 SYN/ACK 标志的数据包。</li><li>第三次握手 - 客户端向服务端发送带有带有 ACK 标志的数据包。</li></ol><p>至此，TCP 三次握手完成，客户端与服务端已建立双向连接。</p><blockquote><p>💡 说明：SYN 为 synchronize 的缩写，ACK 为 acknowledgment 的缩写。</p></blockquote><p>（3）为什么需要三次握手？</p><p>为了便于说明，假设客户端为 A, 服务端为 B。</p><ol><li>第一次握手，A 向 B 发同步消息。B 收到消息后，B 认为：A 发消息没问题；B 收消息没问题。</li><li>第二次握手，B 向 A 发同步消息和确认消息。A 收到消息后，A 认为：A 发消息、收消息都没问题；B 发消息、收消息都没问题。<strong>但是，此时 B 不确定自己发消息是否没问题</strong>，所以就需要第三次握手。</li><li>第三次握手，A 向 B 发确认消息。B 收到消息后。B 认为：B 发消息没问题。</li></ol><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>（1）四次挥手有什么用？</p><ul><li>四次挥手负责断开 TCP 连接。</li></ul><p>（2）什么是四次挥手？</p><p>如上图所示，四次挥手流程如下：</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/四次挥手.gif!zp"/></div><ol><li>第一次挥手 - 客户端向服务端发送一个 FIN 包，用来关闭客户端到服务端的数据传送。</li><li>第二次挥手 - 服务端收到这个 FIN 包，向客户端发送一个 ACK 包，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>第三次挥手 - 服务端关闭与客户端的连接，向客户端发送一个 FIN 包。</li><li>第四次挥手 - 客户端向服务端发送 ACK 包，并将确认序号设置为收到序号加 1。</li></ol><p>（3）为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><ul><li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li><li>而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。</li></ul><h2 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h2><p>什么是滑动窗口？</p><p><strong>滑动窗口是 TCP 的一种控制网络流量的技术。</strong></p><p><strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。</p><p>滑动窗口原理是什么？</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265819762.png"/></div><ol><li>已发送已确认 - 数据流中最早的字节已经发送并得到确认。这些数据是站在发送端的角度来看的。上图中的 31 个字节已经发送并确认。</li><li>已发送但尚未确认 - 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图中的 32 ~ 45 字节为第 2 类。</li><li>未发送而接收方已 Ready - 设备尚未将数据发出 ，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。上图中的 46 ~ 51 字节为第 3 类。</li><li>未发送而接收方 Not Ready - 由于接收方 not ready，还不允许将这部分数据发出。上图中的 52 以后的字节为第 4 类。</li></ol><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559265927658.png"/></div><p>这张图片相对于上一张图片，滑动窗口偏移了 5 个字节，意味着有 5 个已发送的字节得到了确认。</p><h2 id="tcp-重传机制"><a class="markdownIt-Anchor" href="#tcp-重传机制"></a> TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>TCP 重传机制主要有两种：</p><ul><li>超时重传机制</li><li>快速重传机制</li></ul><h3 id="超时重传机制"><a class="markdownIt-Anchor" href="#超时重传机制"></a> 超时重传机制</h3><p>超时重传机制是指：发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO(Retransmission TimeOut)，即重传超时时间。</p><p>没有确认的数据包不会从窗口中移走，定时器在重传时间到期内，每个片段的位置不变。</p><p>这种机制的重点是 RTO 的设置：</p><ul><li>RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>RTO 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发</li></ul><h3 id="快速重传机制"><a class="markdownIt-Anchor" href="#快速重传机制"></a> 快速重传机制</h3><p>快速重传机制，实现了另外的一种丢包评定标准，即如果连续收到 3 次重复 ACK，发送方就认为这个 seq 的包丢失了，立刻进行重传。</p><p>当接收方收到乱序片段时，需要重复发送 ACK。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></li><li><a href="https://juejin.im/post/5a7835a46fb9a063606eb801" target="_blank" rel="noopener">图解 TCP 三次握手与四次分手</a></li><li><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP 的三次握手与四次挥手（详解+动图）</a></li><li><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">TCP 详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络协议之-tcp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络协议之-tcp&quot;&gt;&lt;/a&gt; 网络协议之 TCP&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 UDP</title>
    <link href="https://dunwu.github.io/blog/network/udp/"/>
    <id>https://dunwu.github.io/blog/network/udp/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络协议之-udp"><a class="markdownIt-Anchor" href="#网络协议之-udp"></a> 网络协议之 UDP</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#udp-%E7%89%B9%E7%82%B9">UDP 特点</a></li><li><a href="#udp-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">UDP 应用场景</a></li></ul></li><li><a href="#udp-%E6%8A%A5%E6%96%87">UDP 报文</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559263939493.png"/></div><p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p><p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p><p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p><p>以下情况使用 UDP 代替 TCP：</p><ul><li>你需要低延迟</li><li>相对于数据丢失更糟的是数据延迟</li><li>你想实现自己的错误校正方法</li></ul><h3 id="udp-特点"><a class="markdownIt-Anchor" href="#udp-特点"></a> UDP 特点</h3><ol><li><strong>无连接的</strong>，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li><li><strong>不保证可靠交付</strong>，因此主机不需要为此复杂的连接状态表</li><li><strong>面向报文的</strong>，意思是 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，在添加首部后向下交给 IP 层。</li><li><strong>没有阻塞控制</strong>，因此网络出现的拥塞不会使发送方的发送速率降低。</li><li><strong>支持一对一、一对多、多对一和多对多的交互通信</strong>，也即是提供广播和多播的功能。</li><li><strong>首部开销小</strong>，首部只有 8 个字节，分为四部分。</li></ol><h3 id="udp-应用场景"><a class="markdownIt-Anchor" href="#udp-应用场景"></a> UDP 应用场景</h3><ol><li>名字转换（DNS）</li><li>文件传送（TFTP）</li><li>路由选择协议（RIP）</li><li>IP 地址配置（BOOTP，DHTP）</li><li>网络管理（SNMP）</li><li>远程文件服务（NFS）</li><li>IP 电话</li><li>流式多媒体通信</li></ol><h2 id="udp-报文"><a class="markdownIt-Anchor" href="#udp-报文"></a> UDP 报文</h2><p>UDP 数据报分为数据字段和首部字段。<br />首部字段只有 8 个字节，由四个字段组成，每个字段的长度是 2 个字节。</p><p><strong>首部各字段意义</strong>：</p><ol><li><strong>源端口</strong>：源端口号，在需要对方回信时选用，不需要时可全 0.</li><li><strong>目的端口</strong>：目的端口号，在终点交付报文时必须要使用到。</li><li><strong>长度</strong>：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li><li><strong>检验和</strong>：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络协议之-udp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络协议之-udp&quot;&gt;&lt;/a&gt; 网络协议之 UDP&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络协议之 Websocket</title>
    <link href="https://dunwu.github.io/blog/network/websocket/"/>
    <id>https://dunwu.github.io/blog/network/websocket/</id>
    <published>2019-05-31T03:51:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket-和-websocket"><a class="markdownIt-Anchor" href="#socket-和-websocket"></a> Socket 和 WebSocket</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#socket">Socket</a><ul><li><a href="#socket-%E7%94%A8%E6%B3%95">Socket 用法</a></li><li><a href="#socket-%E9%95%BF%E8%BF%9E%E6%8E%A5">Socket 长连接</a></li></ul></li><li><a href="#websocket">WebSocket</a><ul><li><a href="#websocket-%E7%AE%80%E4%BB%8B">WebSocket 简介</a></li><li><a href="#websocket-%E4%BD%BF%E7%94%A8">WebSocket 使用</a></li></ul></li><li><a href="#faq">FAQ</a><ul><li><a href="#http-vs-socket">Http vs. Socket</a></li><li><a href="#http-%E5%92%8C-websocket-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">HTTP 和 WebSocket 有什么关系？</a></li><li><a href="#html-%E5%92%8C-http-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">Html 和 HTTP 有什么关系？</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h2><p>Socket 作为一种抽象层，应用程序通过它来发送和接收数据，使用 Socket 可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，Socket 提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。</p><h3 id="socket-用法"><a class="markdownIt-Anchor" href="#socket-用法"></a> Socket 用法</h3><p>很多编程语言都支持 Socket。这里以 Java 的 Socket 用法为例。</p><p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <code>ServerSocket</code> 和用于通信的 <code>Socket</code>。使用 socket 的步骤如下：</p><ul><li>创建 <code>ServerSocket</code> 并监听客户连接</li><li>使用 <code>Socket</code> 连接服务端</li><li>通过 <code>Socket</code> 获取输入输出流进行通信</li></ul><h3 id="socket-长连接"><a class="markdownIt-Anchor" href="#socket-长连接"></a> Socket 长连接</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">socket.set<span class="constructor">KeepAlive(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2><h3 id="websocket-简介"><a class="markdownIt-Anchor" href="#websocket-简介"></a> WebSocket 简介</h3><h4 id="websocket-是什么"><a class="markdownIt-Anchor" href="#websocket-是什么"></a> WebSocket 是什么</h4><p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><h4 id="为什么需要-websocket"><a class="markdownIt-Anchor" href="#为什么需要-websocket"></a> 为什么需要 WebSocket</h4><p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p><p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p><p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/spring/web/ajax-long-polling.png"/></div>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/spring/web/websockets-flow.png"/></div>#### WebSocket 如何工作<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p><p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p><h3 id="websocket-使用"><a class="markdownIt-Anchor" href="#websocket-使用"></a> WebSocket 使用</h3><h4 id="websocket-客户端"><a class="markdownIt-Anchor" href="#websocket-客户端"></a> WebSocket 客户端</h4><p>在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var Socket = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h5 id="websocket-属性"><a class="markdownIt-Anchor" href="#websocket-属性"></a> WebSocket 属性</h5><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Socket.readyState</td><td>只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td>Socket.bufferedAmount</td><td>只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h5 id="websocket-事件"><a class="markdownIt-Anchor" href="#websocket-事件"></a> WebSocket 事件</h5><p>以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>事件</th><th>事件处理程序</th><th>描述</th></tr></thead><tbody><tr><td>open</td><td>Socket.onopen</td><td>连接建立时触发</td></tr><tr><td>message</td><td>Socket.onmessage</td><td>客户端接收服务端数据时触发</td></tr><tr><td>error</td><td>Socket.onerror</td><td>通信发生错误时触发</td></tr><tr><td>close</td><td>Socket.onclose</td><td>连接关闭时触发</td></tr></tbody></table><h5 id="websocket-方法"><a class="markdownIt-Anchor" href="#websocket-方法"></a> WebSocket 方法</h5><p>以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Socket.send()</td><td>使用连接发送数据</td></tr><tr><td>Socket.close()</td><td>关闭连接</td></tr></tbody></table><p>WebSocket 客户端代码示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个 WebSocket 对象</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:9998/echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 web socket 连接成功触发事件</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 send() 方法发送数据</span></span><br><span class="line">  ws.send(<span class="string">'发送数据'</span>)</span><br><span class="line">  alert(<span class="string">'数据发送中...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务端数据时触发事件</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> received_msg = evt.data</span><br><span class="line">  alert(<span class="string">'数据已接收...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开 web socket 连接成功触发事件</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'连接已关闭...'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="websocket-服务端"><a class="markdownIt-Anchor" href="#websocket-服务端"></a> WebSocket 服务端</h4><p>WebSocket 在服务端的实现非常丰富。Node.js、Java、C++、Python 等多种语言都有自己的解决方案。</p><p>以下，介绍我在学习 WebSocket 过程中接触过的 WebSocket 服务端解决方案。</p><h5 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs"></a> Node.js</h5><p>常用的 Node 实现有以下三种。</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">µWebSockets</a></li><li><a href="http://socket.io/" target="_blank" rel="noopener">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node" target="_blank" rel="noopener">WebSocket-Node</a></li></ul><h5 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h5><p>Java 的 web 一般都依托于 servlet 容器。</p><p>我使用过的 servlet 容器有：Tomcat、Jetty、Resin。其中 Tomcat7、Jetty7 及以上版本均开始支持 WebSocket（推荐较新的版本，因为随着版本的更迭，对 WebSocket 的支持可能有变更）。</p><p>此外，Spring 框架对 WebSocket 也提供了支持。</p><p>虽然，以上应用对于 WebSocket 都有各自的实现。但是，它们都遵循<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 的通信标准，并且 Java API 统一遵循 <a href="http://www.jcp.org/en/jsr/detail?id=356" target="_blank" rel="noopener">JSR 356 - JavaTM API for WebSocket </a> 规范。所以，在实际编码中，API 差异不大。</p><h5 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h5><p>Spring 对于 WebSocket 的支持基于下面的 jar 包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Spring 实现 WebSocket 服务器大概分为以下几步：</p><p><strong>创建 WebSocket 处理器</strong></p><p>扩展 <code>TextWebSocketHandler</code> 或 <code>BinaryWebSocketHandler</code> ，你可以覆写指定的方法。Spring 在收到 WebSocket 事件时，会自动调用事件对应的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebSocketHandler</code> 源码如下，这意味着你的处理器大概可以处理哪些 WebSocket 事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 收到消息时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 传输消息出错时触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 断开连接后触发的回调</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否处理分片消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置 WebSocket</strong></p><p>配置有两种方式：注解和 xml 。其作用就是将 WebSocket 处理器添加到注册中心。</p><ol><li>实现 <code>WebSocketConfigurer</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(myHandler(), <span class="string">"/myHandler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">myHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml 方式</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">path</span>=<span class="string">"/myHandler"</span> <span class="attr">handler</span>=<span class="string">"myHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myHandler"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.MyHandler"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></p></blockquote><p>javax.websocket</p><p>如果不想使用 Spring 框架的 WebSocket API，你也可以选择基本的 javax.websocket。</p><p>首先，需要引入 API jar 包。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To write basic javax.websocket against --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用嵌入式 jetty，你还需要引入它的实现包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- To run javax.websocket in embedded server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-server-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- To run javax.websocket client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax-websocket-client-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>@ServerEndpoint</strong></p><p>这个注解用来标记一个类是 WebSocket 的处理器。</p><p>然后，你可以在这个类中使用下面的注解来表明所修饰的方法是触发事件的回调</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到消息触发事件</span></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开连接触发事件</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, EndpointConfig config, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接触发事件</span></span><br><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传输消息错误触发事件</span></span><br><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServerEndpointConfig.Configurator</strong></p><p>编写完处理器，你需要扩展 ServerEndpointConfig.Configurator 类完成配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerConfigurator</span> <span class="keyword">extends</span> <span class="title">ServerEndpointConfig</span>.<span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> </span>&#123;</span><br><span class="line">        HttpSession httpSession = (HttpSession) request.getHttpSession();</span><br><span class="line">        sec.getUserProperties().put(HttpSession<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">httpSession</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就没有然后了，就是这么简单。</p><h4 id="websocket-代理"><a class="markdownIt-Anchor" href="#websocket-代理"></a> WebSocket 代理</h4><p>如果把 WebSocket 的通信看成是电话连接，Nginx 的角色则像是电话接线员，负责将发起电话连接的电话转接到指定的客服。</p><p>Nginx 从 <a href="http://nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">1.3 版</a>开始正式支持 WebSocket 代理。如果你的 web 应用使用了代理服务器 Nginx，那么你还需要为 Nginx 做一些配置，使得它开启 WebSocket 代理功能。</p><p>以下为参考配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="comment"># this section is specific to the WebSockets proxying</span></span><br><span class="line">  <span class="attribute">location</span> /socket.io &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app_server_wsgiapp/socket.io;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多配置细节可以参考：<a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></p></blockquote><h4 id="websocket-应用示例"><a class="markdownIt-Anchor" href="#websocket-应用示例"></a> WebSocket 应用示例</h4><p>如果需要完整示例代码，可以参考我的 Github 代码：</p><ul><li><a href="https://github.com/dunwu/spring-notes/tree/master/codes/web/websocket" target="_blank" rel="noopener">Spring 对 WebSocket 支持的示例</a></li><li><a href="https://github.com/dunwu/javaee-notes/tree/master/codes/websocket" target="_blank" rel="noopener">嵌入式 Jetty 服务器的 WebSocket 示例</a></li></ul><p>spring-websocket 和 jetty 9.3 版本似乎存在兼容性问题，Tomcat 则木有问题。</p><p>我尝试了好几次，没有找到解决方案，只好使用 Jetty 官方的嵌入式示例在 Jetty 中使用 WebSocket 。</p><h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2><h3 id="http-vs-socket"><a class="markdownIt-Anchor" href="#http-vs-socket"></a> Http vs. Socket</h3><p>Http 通信与 Socket 通信方式有何差异？</p><ul><li>Http<ul><li>基于请求/响应模式，采取一问一答方式（客户端请求，服务端才会响应）</li></ul></li><li>Socket<ul><li>客户端和服务端建立双向连接。连接成功后，任意一方都可主动发送消息。</li><li>数据丢失率低，使用简单，易于移植。</li></ul></li></ul><h3 id="http-和-websocket-有什么关系"><a class="markdownIt-Anchor" href="#http-和-websocket-有什么关系"></a> HTTP 和 WebSocket 有什么关系？</h3><p>Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。</p><h3 id="html-和-http-有什么关系"><a class="markdownIt-Anchor" href="#html-和-http-有什么关系"></a> Html 和 HTTP 有什么关系？</h3><p>Html 是超文本标记语言，是一种用于创建网页的标准标记语言。它是一种技术标准。Html5 是它的最新版本。</p><p>Http 是一种网络通信协议。其本身和 Html 没有直接关系。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">知乎高票答案——WebSocket 是什么原理</a> - 对 WebSocket 原理的阐述简单易懂。</li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a> - 阮一峰大神的科普一如既往的浅显易懂。</li><li><a href="https://www.fullstackpython.com/websockets.html" target="_blank" rel="noopener">WebSockets</a> - by <em>fullstackpython</em></li><li><a href="http://nginx.org/en/docs/http/websocket.html" target="_blank" rel="noopener">Nginx 官方的 websocket 文档</a></li><li><a href="https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#websocket" target="_blank" rel="noopener">Spring WebSocket 文档</a></li><li><a href="http://tomcat.apache.org/tomcat-7.0-doc/web-socket-howto.html" target="_blank" rel="noopener">Tomcat7 WebSocket 文档</a></li><li><a href="https://www.eclipse.org/jetty/documentation/9.4.7.v20170914/websocket-intro.html" target="_blank" rel="noopener">Jetty WebSocket 文档</a></li><li><a href="https://juejin.im/post/57f885370bd1d00058b37d74" target="_blank" rel="noopener">Socket，你需要知道的事儿</a></li><li><a href="https://juejin.im/post/5b3649d751882552f052703b" target="_blank" rel="noopener">手把手教你写 Socket 长连接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;socket-和-websocket&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#socket-和-websocket&quot;&gt;&lt;/a&gt; Socket 和 WebSocket&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议" scheme="https://dunwu.github.io/blog/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>网络通信之 CDN</title>
    <link href="https://dunwu.github.io/blog/network/cdn/"/>
    <id>https://dunwu.github.io/blog/network/cdn/</id>
    <published>2019-05-29T15:19:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信之-cdn"><a class="markdownIt-Anchor" href="#网络通信之-cdn"></a> 网络通信之 CDN</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#cdn-%E6%98%AF%E4%BB%80%E4%B9%88">CDN 是什么</a></li><li><a href="#cdn-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">CDN 的优缺点</a></li></ul></li><li><a href="#cdn-%E5%8E%9F%E7%90%86">CDN 原理</a><ul><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8">分布式存储</a></li><li><a href="#%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86">内容管理</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91">网络请求的重定向</a></li></ul></li><li><a href="#cdn-%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B">CDN 访问流程</a></li><li><a href="#%E6%8E%A8%E9%80%81%E5%92%8C%E6%8B%89%E5%8F%96">推送和拉取</a><ul><li><a href="#cdn-%E6%8E%A8%E9%80%81">CDN 推送</a></li><li><a href="#cdn-%E6%8B%89%E5%8F%96">CDN 拉取</a></li></ul></li><li><a href="#%E8%B5%84%E6%BA%90">资源</a></li></ul><!-- /TOC --><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559138689425.png"/></div><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="cdn-是什么"><a class="markdownIt-Anchor" href="#cdn-是什么"></a> CDN 是什么</h3><p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p><p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p><h3 id="cdn-的优缺点"><a class="markdownIt-Anchor" href="#cdn-的优缺点"></a> CDN 的优缺点</h3><ul><li>优点<ul><li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li><li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li></ul></li><li>缺点<ul><li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li><li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li><li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li></ul></li></ul><h2 id="cdn-原理"><a class="markdownIt-Anchor" href="#cdn-原理"></a> CDN 原理</h2><p>CDN 的基本原理是：</p><ul><li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li><li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li><li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li></ul><p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p><ul><li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li><li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li></ul><p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p><h3 id="分布式存储"><a class="markdownIt-Anchor" href="#分布式存储"></a> 分布式存储</h3><p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559140068433.png"/></div><p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p><h3 id="内容管理"><a class="markdownIt-Anchor" href="#内容管理"></a> 内容管理</h3><p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有&quot;一跳&quot;(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）<strong>和</strong>本地负载均衡（SLB）</strong>。</p><h3 id="网络请求的重定向"><a class="markdownIt-Anchor" href="#网络请求的重定向"></a> 网络请求的重定向</h3><p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="cdn-访问流程"><a class="markdownIt-Anchor" href="#cdn-访问流程"></a> CDN 访问流程</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559126750010.png"/></div><ol><li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li><li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li><li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li><li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li><li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li></ol><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li></ul></blockquote><h2 id="推送和拉取"><a class="markdownIt-Anchor" href="#推送和拉取"></a> 推送和拉取</h2><p>CDN 服务有推送和拉取两种方式：</p><h3 id="cdn-推送"><a class="markdownIt-Anchor" href="#cdn-推送"></a> CDN 推送</h3><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p><p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p><p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p><h3 id="cdn-拉取"><a class="markdownIt-Anchor" href="#cdn-拉取"></a> CDN 拉取</h3><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p><p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p><p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p><p>优点在于实现简单。</p><blockquote><p>参考：<a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></p></blockquote><h2 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h2><ul><li>文章<ul><li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">Wikipedia - CDN</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2012/12/18/2824141.html" target="_blank" rel="noopener">CDN-内容推送网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/39028766" target="_blank" rel="noopener">闲话 CDN</a></li><li><a href="https://www.cnblogs.com/losbyday/p/5843960.html" target="_blank" rel="noopener">CDN 技术详解</a></li><li><a href="https://segmentfault.com/q/1010000000119794" target="_blank" rel="noopener">推送式与拉取式 CDN 服务的优劣问题</a></li></ul></li><li>CDN 资源<ul><li><a href="https://staticfile.org/" target="_blank" rel="noopener">https://staticfile.org/</a></li><li><a href="https://unpkg.com/" target="_blank" rel="noopener">https://unpkg.com/</a></li><li><a href="https://cdnjs.com/" target="_blank" rel="noopener">https://cdnjs.com/</a></li><li><a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li><a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信之-cdn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络通信之-cdn&quot;&gt;&lt;/a&gt; 网络通信之 CDN&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Windows 常用技巧总结</title>
    <link href="https://dunwu.github.io/blog/os/windows/"/>
    <id>https://dunwu.github.io/blog/os/windows/</id>
    <published>2019-05-07T12:35:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows-常用技巧总结"><a class="markdownIt-Anchor" href="#windows-常用技巧总结"></a> Windows 常用技巧总结</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E8%BD%AF%E4%BB%B6">软件</a><ul><li><a href="#%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91">视频音频</a></li><li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li><li><a href="#%E5%BC%80%E5%8F%91">开发</a></li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li><li><a href="#%E6%96%87%E6%A1%A3">文档</a></li><li><a href="#%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87">效率提升</a></li><li><a href="#%E5%8A%9E%E5%85%AC">办公</a></li><li><a href="#%E4%B8%AA%E6%80%A7%E5%8C%96">个性化</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2><blockquote><p>扩展阅读：</p><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">Awesome Windows</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">best-windows-apps</a></li></ul></blockquote><h3 id="视频音频"><a class="markdownIt-Anchor" href="#视频音频"></a> 视频音频</h3><ul><li><a href="http://getmusicbee.com/" target="_blank" rel="noopener">Musicbee</a> - 类似 iTunes，但比 iTunes 更好用。</li><li><a href="http://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a> - 它允许你录制屏幕的一部分区域并保存为 gif 或视频。</li><li><a href="http://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a> - 多媒体播放器，具有广泛的编解码器集合，它还为用户提供大量配置选项。</li><li><a href="http://www.splayer.org/" target="_blank" rel="noopener">射手影音播放器</a> - 来自射手网，小巧开源，首创自动匹配字幕功能。</li></ul><h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3><ul><li><a href="http://www.7-zip.org/" target="_blank" rel="noopener">7-Zip</a> - 用于处理压缩包的开源 Windows 实用程序。完美支持 7z，ZIP，GZIP，BZIP2 和 TAR 的全部特性，其他格式也可解压缩。</li><li><a href="http://www.rarlab.com/" target="_blank" rel="noopener">WinRAR</a> - 强大的归档管理器。 它可以备份您的数据并减小电子邮件附件的大小，解压缩 RAR，ZIP 和其他文件。</li></ul><h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3><ul><li><a href="http://en.ejie.me/" target="_blank" rel="noopener">Clover</a> - 为资源管理器加上多标签功能。</li><li><a href="http://www.ghisler.com/" target="_blank" rel="noopener">Total Commander</a> - 老牌、功能异常强大的文件管理增强软件。</li><li><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir" target="_blank" rel="noopener">Q-Dir</a> - 轻量级的文件管理器，各种布局视图切换灵活，默认四个小窗口组成一个大窗口，操作快捷。软件虽小，粉丝忠诚。</li><li><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">WoX</a> - 新一代文件定位工具，堪称 Windows 上的 Alfred。</li><li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> - 最快的文件/文件夹搜索工具， 通过名称搜索。</li><li><a href="http://www.listary.com/" target="_blank" rel="noopener">Listary</a> - 非常优秀的 Windows 文件浏览和搜索增强工具。</li><li>Beyond Compare - 好用又万能的文件对比工具。</li><li><a href="https://www.piriform.com/ccleaner/download" target="_blank" rel="noopener">CCleaner</a> - 如果你有系统洁癖，那一定要选择一款干净、良心、老牌的清洁软件。</li><li><a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey</a> - 包管理器</li><li><a href="https://ninite.com/" target="_blank" rel="noopener">Ninite</a> - 最简单，最快速的更新或安装软件的方式。</li><li><a href="http://www.piriform.com/RECUVA" target="_blank" rel="noopener">Recuva</a> - 来自 piriform 梨子公司产品，免费的数据恢复工具。</li><li><a href="http://www.launchy.net/" target="_blank" rel="noopener">Launchy</a>：自由的跨平台工具，帮助你忘记开始菜单、桌面图标甚至文件管理器。</li></ul><h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3><ul><li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a> - web 调试代理工具。</li><li><a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman</a> - 适合 API 开发的完整工具链，最常用的 REST 客户端。</li><li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> - 一个免费的 Git &amp; Mercurial 客户端。</li><li><a href="https://tortoisesvn.net/" target="_blank" rel="noopener">TortoiseSVN</a> - Subversion(SVN)的图形客户端</li><li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> - 一个网络协议分析工具。</li><li>Switchhosts</li><li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">Cmder</a> - 控制台模拟器包。扩展阅读：<a href="https://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">Win 下必备神器之 Cmder</a></li><li><a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a> - 基于 Cygwin，用于替代 Windows shell。</li></ul><h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3><ul><li><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">JetBrain IDE 系列</a> - 真香！</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> - 用于构建和调试现代 Web 和云应用程序。</li><li><a href="https://eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a> - 一款功能强大的 IDE。</li><li><a href="https://www.visualstudio.com/vs/" target="_blank" rel="noopener">Visual Studio</a> - 微软官方的 IDE，通过插件可支持大量编程语言。</li><li><a href="https://netbeans.org/" target="_blank" rel="noopener">NetBeans IDE</a> - 免费开源的 IDE。</li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人觉得最好用的 Markdown 编辑器。</li><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a> - 跨平台优秀 Markdown 编辑器，本文即用其所写。</li><li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> - 一款支持多种编程语言的源码编辑器。</li><li><a href="http://www.flos-freeware.ch/notepad2.html" target="_blank" rel="noopener">Notepad2</a> - 用于替代默认文本编辑器的轻量快速的编辑器，拥有众多有用的功能。</li><li><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> - 高级文本编辑器。</li><li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> - 面向 21 世纪的极客文本编辑器。</li></ul><h3 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h3><ul><li><a href="http://www.office.com/" target="_blank" rel="noopener">Microsoft Office</a> - 微软办公软件。</li><li><a href="https://www.wps.com/office-free" target="_blank" rel="noopener">WPS Office</a> - 金山免费办公软件。</li><li><a href="http://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a> - 用于电子书管理和转换的强大软件。</li><li><a href="http://www.foxitsoftware.cn/products/reader/" target="_blank" rel="noopener">福昕阅读器</a> - 在全球拥有大量用户，最优秀的国产软件之一。Ribbon 界面，支持手写签名、插入印章等。</li></ul><h3 id="效率提升"><a class="markdownIt-Anchor" href="#效率提升"></a> 效率提升</h3><p><strong>【笔记】</strong></p><ul><li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a> - 优秀的思维导图。</li><li><a href="https://www.onenote.com/" target="_blank" rel="noopener">OneNote</a> - Windows 下综合评价非常高的笔记应用。</li><li><a href="http://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a> - 老牌跨平台笔记工具，国际版 Evernote。一家立志于做百年公司的企业，安全、可靠。</li><li><a href="http://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> - 越来越好的笔记应用，记录、查阅一切有价值的信息，同样跨平台支持。</li><li><a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a> - 网易旗下笔记工具，同样跨主流平台支持，文字、手写、录音、拍照多种记录方式，支持任意附件格式。</li><li><a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a> - 你要的所有与截图、录屏相关的功能，这里都有了。</li></ul><p>【快捷键】</p><ul><li><a href="https://autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a> - Windows 平台的终极自动化脚本语言。</li></ul><blockquote><p>技巧：</p><ul><li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/" target="_blank" rel="noopener">https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296" target="_blank" rel="noopener">https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296</a></li></ul></blockquote><h3 id="办公"><a class="markdownIt-Anchor" href="#办公"></a> 办公</h3><ul><li><a href="http://cidian.youdao.com/index.html" target="_blank" rel="noopener">有道词典</a> - 最好用的免费全能翻译软件。</li><li><a href="http://office.microsoft.com/zh-cn/outlook/" target="_blank" rel="noopener">Outlook</a> - 大名鼎鼎的 Microsoft Office 组件之一，除了电子邮件，还包含了日历、任务管理、联系人、记事本等功能。</li><li><a href="http://www.gmail.com/" target="_blank" rel="noopener">Gmail</a> - 功能上可以称为业界标杆，用户数量世界第一，或许你真的找不到比它更好的邮件系统。</li><li><a href="https://www.google.com/intl/zh-CN/chrome/browser/" target="_blank" rel="noopener">Chrome</a> - 最好的浏览器。</li><li><a href="http://www.teamviewer.com/Zhcn/index.aspx" target="_blank" rel="noopener">Teamviewer</a> - 专业、功能强大的远程控制软件。使用简单，对个人用户免费。</li></ul><h3 id="个性化"><a class="markdownIt-Anchor" href="#个性化"></a> 个性化</h3><ul><li><a href="https://github.com/TranslucentTB/TranslucentTB" target="_blank" rel="noopener">TranslucentTB</a> - 透明化你的 Windows 任务栏。</li><li><a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a> - 通过多标签和额外的文件夹视图扩展资源管理器的功能。</li><li><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a> - 管理桌面快捷方式。</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md</a></li><li><a href="https://love.appinn.com/" target="_blank" rel="noopener">https://love.appinn.com/</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">https://github.com/stackia/best-windows-apps</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows-常用技巧总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows-常用技巧总结&quot;&gt;&lt;/a&gt; Windows 常用技巧总结&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Windows" scheme="https://dunwu.github.io/blog/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Mac 常用技巧总结</title>
    <link href="https://dunwu.github.io/blog/os/mac/"/>
    <id>https://dunwu.github.io/blog/os/mac/</id>
    <published>2019-05-07T12:35:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2><h3 id="软件管理"><a class="markdownIt-Anchor" href="#软件管理"></a> 软件管理</h3><p>dmg 格式：双击安装包，然后拖到 applications 文件夹下即可。</p><h3 id="浏览器"><a class="markdownIt-Anchor" href="#浏览器"></a> 浏览器</h3><h4 id="更改默认搜索引擎"><a class="markdownIt-Anchor" href="#更改默认搜索引擎"></a> 更改默认搜索引擎</h4><p>选择「偏好设置–&gt;搜索–&gt;搜索引擎–&gt;Google」。</p><h4 id="导入-chrome-浏览器的书签"><a class="markdownIt-Anchor" href="#导入-chrome-浏览器的书签"></a> 导入 chrome 浏览器的书签</h4><p>选择「文件–&gt;导入自–&gt; Google Chrome」，然后选择要导入的项目。</p><h4 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h4><p>Command + R 刷新</p><h4 id="上方显示书签栏收藏栏"><a class="markdownIt-Anchor" href="#上方显示书签栏收藏栏"></a> 上方显示书签栏／收藏栏</h4><p>选择「显示–&gt; 显示个人收藏栏」。</p><h4 id="关闭软件的右上角通知"><a class="markdownIt-Anchor" href="#关闭软件的右上角通知"></a> 关闭软件的右上角通知</h4><p>在 Mac 系统中有对通知的设置，打开系统偏好设置 — 通知 找到 QQ，然后将 QQ 提示样式设置成无即可。</p><h4 id="复制文件文件夹路径"><a class="markdownIt-Anchor" href="#复制文件文件夹路径"></a> 复制文件/文件夹路径</h4><ul><li>OS X 10.11 系统，选中文件夹，「cmd +Option +c」 复制文件夹路径，cmd+v 粘贴。<br />之前的系统，利用 Administrator 创建一个到右键菜单，然后到设置里面设置快捷键。具体操作请百度。</li></ul><h4 id="打开来自身份不明的开发者的应用程序"><a class="markdownIt-Anchor" href="#打开来自身份不明的开发者的应用程序"></a> 打开来自身份不明的开发者的应用程序</h4><p>在应用程序文件夹，按住 control 键的同时打开应用程序。</p><h4 id="复制文件路径"><a class="markdownIt-Anchor" href="#复制文件路径"></a> 复制文件路径</h4><ul><li><p>选择文件／文件夹按 Command+C 复制，在终端中 Command+V 粘贴即可。</p></li><li><p>如果只是想在 Finder 中看到文件的路径, 并方便切换层级, Finder 内置了「显示路径栏」的功能, 并配置了快捷键(Option+Cmd+P). 如下图所示：</p></li></ul><p>20161124-184148.png</p><p>参考链接：</p><ul><li>[<a href="https://www.zhihu.com/question/22883229" target="_blank" rel="noopener">https://www.zhihu.com/question/22883229</a>]</li></ul><h3 id="隐藏和取消隐藏-mac-app-store-中的已购项目"><a class="markdownIt-Anchor" href="#隐藏和取消隐藏-mac-app-store-中的已购项目"></a> 隐藏和取消隐藏 Mac App Store 中的已购项目</h3><h3 id="mac-同时登陆两个-qq"><a class="markdownIt-Anchor" href="#mac-同时登陆两个-qq"></a> Mac 同时登陆两个 QQ</h3><p>在已经打开的 QQ 中，按住「command + N」即可。</p><h2 id="系统便好设置"><a class="markdownIt-Anchor" href="#系统便好设置"></a> 系统便好设置</h2><h3 id="语音播报"><a class="markdownIt-Anchor" href="#语音播报"></a> 语音播报</h3><p>打开「系统便好设置–&gt;辅助功能–&gt;语音」，即可设置不同国家的语言。</p><p>勾选上图中的红框部分，可以设置全局快捷键。这样的话，在任何一个软件当中，按下「 option+esc」时，就会朗读选中的文本。</p><h3 id="调整字体大小"><a class="markdownIt-Anchor" href="#调整字体大小"></a> 调整字体大小</h3><p>Mac 调整字体大小：「系统偏好设置 -&gt; 显示器 -&gt; 缩放」。如下图：</p><h3 id="如何分别设置-mac-的鼠标和触控板的滚动方向"><a class="markdownIt-Anchor" href="#如何分别设置-mac-的鼠标和触控板的滚动方向"></a> 如何分别设置 Mac 的鼠标和触控板的滚动方向</h3><p>很多人习惯鼠标使用相反的滚动方向，而触控板类似 iPad 那样的自然滚动，问如何设置，当时我的回答是不知道，因为目前 OS X 的系统设置里，鼠标和触控板的设置是统一<br />的。今天发现了一个免费的软件 Scroll Reverser，可以实现鼠标和触控板的分别设置。下载地址：<a href="https://pilotmoon.com/scrollreverser/" target="_blank" rel="noopener">https://pilotmoon.com/scrollreverser/</a><br />启动后程序显示在顶部菜单栏，设置简单明了，有需要的用户体验一下吧。</p><h3 id="touch-bar-自定义"><a class="markdownIt-Anchor" href="#touch-bar-自定义"></a> Touch Bar 自定义</h3><p>打开「系统偏好设置-键盘」，下面有个自定义控制条。</p><h3 id="色温调节夜间模式"><a class="markdownIt-Anchor" href="#色温调节夜间模式"></a> 色温调节：夜间模式</h3><p>iOS9.3 的最明显变化，莫过于苹果在发布会上特意提到的 Night Shift 夜间护眼模式。</p><h3 id="icloud-邮箱"><a class="markdownIt-Anchor" href="#icloud-邮箱"></a> iCloud 邮箱</h3><p>如果您用于设置 iCloud 的 Apple ID 不以“@icloud.com”、“@me.com”或“@mac.com”结尾，您必须先设置一个“@icloud.com”电子邮件地址，然后才能使用 iCloud“邮件”。</p><p>如果您拥有以“@mac.com”或“@me.com”结尾的电子邮件地址，则您已经拥有了名称相同但以“@icloud.com”结尾的等效地址。如果您使用的电子邮件别名以“@mac.com”或“@me.com”结尾，您也将拥有以“@icloud.com”结尾的等效地址。</p><p><strong>操作如下：</strong></p><ul><li><p>在 iOS 设备上，前往“设置”&gt;“iCloud”，开启“邮件”，然后按照屏幕上的说明操作。</p></li><li><p>在 Mac 上，选取 Apple 菜单 &gt;“系统偏好设置”，点按“iCloud”，再选择“邮件”，然后按照屏幕上的说明操作。</p></li></ul><p>PS：创建 iCloud 电子邮件地址后，您无法对其进行更改。</p><p>设置 @icloud.com 电子邮件地址后即可用其登录 iCloud。您也可以用创建 iCloud 帐户时所用的 Apple ID 登录。</p><p>您可以从以下任意地址发送 iCloud 电子邮件：</p><p>您的 iCloud 电子邮件地址（您的帐号名称@icloud.com）</p><p>别名</p><p>参考链接：</p><p><strong>直接注册以@icloud.com 结尾的 Apple ID：</strong></p><p>参考链接：</p><h2 id="podcast"><a class="markdownIt-Anchor" href="#podcast"></a> PodCast</h2><p>PodCast 中文翻译为播客，是一种特殊的音频 or 视频节目。PodCast 这个单词是由 iPod+Broadcast 这两个单词组成的。</p><p>PodCast 可以在 iTunes 中收听。</p><h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h2><h3 id="词典"><a class="markdownIt-Anchor" href="#词典"></a> 词典</h3><p>系统有一个自带应用「词典」，可以进行单词的查询。</p><h3 id="如何解决-mac-软件dmgakpapp出现程序已损坏的提示"><a class="markdownIt-Anchor" href="#如何解决-mac-软件dmgakpapp出现程序已损坏的提示"></a> 如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</h3><p>「xxx.app 已损坏,打不开.你应该将它移到废纸篓」，并非你安装的软件已损坏，而是 Mac 系统的安全设置问题，因为这些应用都是破解或者汉化的,那么解决方法就是临时改变 Mac 系统安全设置。</p><p>出现这个问题的解决方法：修改系统配置：系统偏好设置… -&gt; 安全性与隐私。修改为任何来源。</p><p>如果没有这个选项的话（macOS Sierra 10.12）,打开终端，执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>即可。</p><p>参考链接：</p><ul><li><p><a href="http://www.jianshu.com/p/379b49b88df9" target="_blank" rel="noopener">Max OS-[xxx.app 已损坏,打不开.你应该将它移到废纸篓]</a></p></li><li><p><a href="http://www.yunrui.co/25693.html" target="_blank" rel="noopener">如何解决 MAC 软件（dmg，akp，app）出现程序已损坏的提示</a></p></li></ul><p>备注：这个链接里的各种资源都很不错啊。</p><h4 id="终端"><a class="markdownIt-Anchor" href="#终端"></a> 终端</h4><h4 id="在-finder-的当前目录打开终端"><a class="markdownIt-Anchor" href="#在-finder-的当前目录打开终端"></a> 在 Finder 的当前目录打开终端</h4><p>在 Finder 打开 terminal 终端这个功能其实是有的，但是系统默认没有打开。我们可以通过如下方法将其打开：</p><p>进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。</p><p>在右边新建位于文件夹位置的终端窗口上打勾。</p><p>如此设置后，在 Finder 中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可！</p><h2 id="mac-常用快捷键"><a class="markdownIt-Anchor" href="#mac-常用快捷键"></a> Mac 常用快捷键</h2><h3 id="finder"><a class="markdownIt-Anchor" href="#finder"></a> Finder</h3><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">作用</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">Shift + Command + G</td><td style="text-align:left">前往指定路径的文件夹</td><td style="text-align:left">包括隐藏文件夹</td></tr><tr><td style="text-align:left">Shift + Command + .</td><td style="text-align:left">显示隐藏文件、文件夹</td><td style="text-align:left">再按一次，恢复隐藏</td></tr><tr><td style="text-align:left">Command + ↑</td><td style="text-align:left">返回上一层</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Command + ↓</td><td style="text-align:left">进入当前文件夹</td><td style="text-align:left"></td></tr></tbody></table><h3 id="编辑"><a class="markdownIt-Anchor" href="#编辑"></a> 编辑</h3><p><strong>删除文字</strong>：</p><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:left">作用</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">delete</td><td style="text-align:left">删除光标的前一个字符</td><td style="text-align:left">相当于 Windows 键盘上的退格键</td></tr><tr><td style="text-align:left">fn + delete</td><td style="text-align:left">删除光标的后一个字符</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">option + delete</td><td style="text-align:left">删除光标之前的一个单词</td><td style="text-align:left">英文有效</td></tr><tr><td style="text-align:left"><strong>command + delete</strong></td><td style="text-align:left">删除光标之前的整行内容</td><td style="text-align:left">【荐】</td></tr><tr><td style="text-align:left">command + delete</td><td style="text-align:left">在 finder 中删掉该文件</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">shift + command + delete</td><td style="text-align:left">清空回收站</td><td style="text-align:left"></td></tr></tbody></table><p><strong>剪切文件</strong>：</p><p>首先选中文件，按 Command+C 复制文件；然后按「Command ＋ Option ＋ V」剪切文件。</p><p>备注：Command+X 只能剪切文字文本，不要混淆了。</p><h2 id="mac-用户必须知道的-15-组快捷键"><a class="markdownIt-Anchor" href="#mac-用户必须知道的-15-组快捷键"></a> Mac 用户必须知道的 15 组快捷键</h2><blockquote><p>参考链接：<a href="http://v.youku.com/v_show/id_XNDE4MzM0NDgw.html" target="_blank" rel="noopener">《轻松玩 Mac》第 6 期：Mac 用户必须知道的 15 组快捷键</a></p></blockquote><h3 id="space键快速预览"><a class="markdownIt-Anchor" href="#space键快速预览"></a> 「space」键：快速预览</h3><p>选中文件后， 不需要启动任何应用程序，使用「space」空格键可进行快速预览，再次按下「space」空格键取消预览。</p><p>可以预览 mp3、视频、pdf 等文件。</p><p>我们还可以<strong>选中多张图片</strong>， 然后按「space」键，就可以同时对比预览多张图片。这一点，很赞。</p><h3 id="改名"><a class="markdownIt-Anchor" href="#改名"></a> 改名</h3><p>选中文件/文件夹后，按 enter 键，就可以改名了。</p><h3 id="command-i键查看文件属性"><a class="markdownIt-Anchor" href="#command-i键查看文件属性"></a> 「command + I」键：查看文件属性</h3><ul><li><p>选中文件后，按「command + I」键，可以查看文件的各种属性。</p></li><li><p>选中<strong>文件夹</strong>后，按「command + I」键，可以查看文件夹的大小。【荐】</p></li></ul><h3 id="切换输入法"><a class="markdownIt-Anchor" href="#切换输入法"></a> 切换输入法</h3><p>「control + space」</p><h3 id="打开-spotlight-搜索框"><a class="markdownIt-Anchor" href="#打开-spotlight-搜索框"></a> 打开 spotlight 搜索框</h3><p>spotlight 是系统自带的软件，搜索功能不是很强大。我们一般都会用第三方的 Alfred 软件。</p><h3 id="编辑相关"><a class="markdownIt-Anchor" href="#编辑相关"></a> 编辑相关</h3><p>Cmd+C、Cmd+V、Cmd+X、Cmd+A、Cmd+Z。</p><h3 id="翻页和光标"><a class="markdownIt-Anchor" href="#翻页和光标"></a> 翻页和光标</h3><ul><li><p>「control + ↑」：将光标定位到文章的最开头（翻页到文档的最上方）</p></li><li><p>「control + ↓」：将光标定位到文章的最末尾（翻页到文档的最下方）</p></li><li><p>「control + ←」：将光标定位到当前行的最左侧</p></li><li><p>「control + →」：将光标定位到当前行的最右侧</p></li></ul><h3 id="command-shift-y将文字快速保存到便笺"><a class="markdownIt-Anchor" href="#command-shift-y将文字快速保存到便笺"></a> 「command + shift + Y」：将文字快速保存到便笺</h3><p>选中你想要的内容（例如文字、链接等），然后按下 command + shift + Y」，那么你选中的内容就会快速保存到系统自带的「便笺」软件中。</p><p>如果你想临时性的保存一段内容，这个操作很实用。</p><h3 id="程序相关"><a class="markdownIt-Anchor" href="#程序相关"></a> 程序相关</h3><ul><li><p>「command + Q」：快速退出程序</p></li><li><p>「command + tab」：切换程序</p></li><li><p>「command + H」：隐藏当前应用程序。这是一个有趣的快捷键。</p></li><li><p>「command + ，」：打开当前应用程序的「偏好设置」。</p></li></ul><h3 id="窗口相关"><a class="markdownIt-Anchor" href="#窗口相关"></a> 窗口相关</h3><ul><li><p>「command + N」：新建一个当前应用程序的窗口</p></li><li><p>「command + `」：在当前应用程序的不同窗口之间切换【很实用】</p></li></ul><p>我们知道，「command + tab」是在不同的软件之间切换。但你不知道的是，「command + `」是在同一个软件的不同窗口之间切换。</p><ul><li><p>「command + M」：将当前窗口最小化</p></li><li><p>「command + W」：关闭当前窗口</p></li></ul><h3 id="浏览器相关"><a class="markdownIt-Anchor" href="#浏览器相关"></a> 浏览器相关</h3><ul><li><p>「command + T」：浏览器中，新建一个标签</p></li><li><p>「command + W」：关闭当前标签</p></li></ul><ul><li>「command + R」：强制刷新。</li></ul><ul><li>「command + L」：定位到地址栏。【重要】</li></ul><h3 id="截图相关"><a class="markdownIt-Anchor" href="#截图相关"></a> 截图相关</h3><ul><li>「command + shift + 3」：截全屏（对整个屏幕截图）。</li></ul><h3 id="声音相关"><a class="markdownIt-Anchor" href="#声音相关"></a> 声音相关</h3><p>选中文字后，按住「ctrl + esc」键，会将文字进行朗读。（我发现，在触控条版的 mac 上，并没有生效）</p><h3 id="dock-栏相关"><a class="markdownIt-Anchor" href="#dock-栏相关"></a> Dock 栏相关</h3><ul><li>「option + command + D」：隐藏 dock 栏</li></ul><h3 id="强制推出"><a class="markdownIt-Anchor" href="#强制推出"></a> 强制推出</h3><blockquote><p>强制退出的快捷键非常重要</p></blockquote><ul><li>「option + command + esc」：打开强制退出的窗口</li></ul><h3 id="option-相关"><a class="markdownIt-Anchor" href="#option-相关"></a> option 相关</h3><blockquote><p>强烈推荐</p></blockquote><ul><li><p>「option + command + H」：隐藏除当前应用程序之外的其他应用程序</p></li><li><p>在文本中，按住「option」键，配合鼠标的选中，可以进行块状文字选取。</p></li><li><p>「option + command + W」：快速关闭当前应用程序的所有窗口。【很实用】</p></li></ul><p>比如说，你一次性打开了很多文件的详情，然后就可以通过此快捷键，将这些窗口一次性关闭。</p><ul><li>「option + command + I」：查看多个文件的总的属性。</li></ul><ul><li><p>打开 launchpad，按住「option」键，可以快速卸载应用程序。</p></li><li><p>在 dock 栏，右键点击软件图标，同时按住「option」键，就可以<strong>强制退出</strong>该软件。【重要】</p></li></ul><ul><li>在 Safari 浏览器中，按住「option + command + Q」退出 Safari。等下次进入 Safari 的时候，上次退出时的网址会自动被打开。【实用】</li></ul><h3 id="推荐一个软件cheatsheet"><a class="markdownIt-Anchor" href="#推荐一个软件cheatsheet"></a> 推荐一个软件：CheatSheet</h3><p>打开 CheatSheet 后，长按 command 键，会弹出当前应用程序的所有快捷键。我们还可以对这些快捷键进行保存。</p><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><ul><li><a href="https://github.com/jaywcjlove/awesome-mac" target="_blank" rel="noopener">Awesome Mac</a></li><li><a href="https://github.com/herrbischoff/awesome-macos-command-line" target="_blank" rel="noopener">awesome-macos-command-line</a></li></ul><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本操作&quot;&gt;&lt;/a&gt; 基本操作&lt;/h2&gt;
&lt;h3 id=&quot;软件管理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件管理&quot;&gt;&lt;/a&gt; 软件管理&lt;/h3
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://dunwu.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mac" scheme="https://dunwu.github.io/blog/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之应用层</title>
    <link href="https://dunwu.github.io/blog/network/network-application/"/>
    <id>https://dunwu.github.io/blog/network/network-application/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络之应用层"><a class="markdownIt-Anchor" href="#计算机网络之应用层"></a> 计算机网络之应用层</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#http">HTTP</a></li><li><a href="#dns">DNS</a></li><li><a href="#ftp">FTP</a></li><li><a href="#dhcp">DHCP</a></li><li><a href="#telnet">TELNET</a></li><li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE">电子邮件协议</a><ul><li><a href="#1-smtp">1. SMTP</a></li><li><a href="#2-pop3">2. POP3</a></li><li><a href="#3-imap">3. IMAP</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3">常用端口</a></li><li><a href="#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">Web 页面请求过程</a><ul><li><a href="#1-dhcp-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF">1. DHCP 配置主机信息</a></li><li><a href="#2-arp-%E8%A7%A3%E6%9E%90-mac-%E5%9C%B0%E5%9D%80">2. ARP 解析 MAC 地址</a></li><li><a href="#3-dns-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D">3. DNS 解析域名</a></li><li><a href="#4-http-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2">4. HTTP 请求页面</a></li></ul></li></ul><!-- /TOC --><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551096916007.png"/></div><p>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p><p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><p>安全套接字层超文本传输协议 HTTPS 为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><blockquote><p>👉 扩展阅读：<a href="HTTP.md">HTTP</a></p></blockquote><h2 id="dns"><a class="markdownIt-Anchor" href="#dns"></a> DNS</h2><p>域名服务器 DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551094759786.png"/></div><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551094954067.png"/></div><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><blockquote><p>👉 扩展阅读：<a href="DNS.md">DNS</a></p></blockquote><h2 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> FTP</h2><p>文件传送协议 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><ul><li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551095440002.png"/></div><ul><li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li><li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li></ul><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><p>FTPS 是一种对常用的文件传输协议（FTP）添加传输层安全（TLS）和安全套接层（SSL）加密协议支持的扩展协议。</p><h2 id="dhcp"><a class="markdownIt-Anchor" href="#dhcp"></a> DHCP</h2><p>动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/application/1551095610521.png"/></div><h2 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> TELNET</h2><p>远程登录协议 TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a class="markdownIt-Anchor" href="#电子邮件协议"></a> 电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><h3 id="1-smtp"><a class="markdownIt-Anchor" href="#1-smtp"></a> 1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><h3 id="2-pop3"><a class="markdownIt-Anchor" href="#2-pop3"></a> 2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p><h3 id="3-imap"><a class="markdownIt-Anchor" href="#3-imap"></a> 3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p><h2 id="常用端口"><a class="markdownIt-Anchor" href="#常用端口"></a> 常用端口</h2><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">端口号</th><th style="text-align:center">传输层协议</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">域名解析</td><td style="text-align:center">DNS</td><td style="text-align:center">53</td><td style="text-align:center">UDP/TCP</td><td style="text-align:center">长度超过 512 字节时使用 TCP</td></tr><tr><td style="text-align:center">动态主机配置协议</td><td style="text-align:center">DHCP</td><td style="text-align:center">67/68</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单网络管理协议</td><td style="text-align:center">SNMP</td><td style="text-align:center">161/162</td><td style="text-align:center">UDP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">文件传送协议</td><td style="text-align:center">FTP</td><td style="text-align:center">20/21</td><td style="text-align:center">TCP</td><td style="text-align:center">控制连接 21，数据连接 20</td></tr><tr><td style="text-align:center">远程终端协议</td><td style="text-align:center">TELNET</td><td style="text-align:center">23</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">超文本传送协议</td><td style="text-align:center">HTTP</td><td style="text-align:center">80</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">简单邮件传送协议</td><td style="text-align:center">SMTP</td><td style="text-align:center">25</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">邮件读取协议</td><td style="text-align:center">POP3</td><td style="text-align:center">110</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">网际报文存取协议</td><td style="text-align:center">IMAP</td><td style="text-align:center">143</td><td style="text-align:center">TCP</td><td style="text-align:center"></td></tr></tbody></table><h2 id="web-页面请求过程"><a class="markdownIt-Anchor" href="#web-页面请求过程"></a> Web 页面请求过程</h2><h3 id="1-dhcp-配置主机信息"><a class="markdownIt-Anchor" href="#1-dhcp-配置主机信息"></a> 1. DHCP 配置主机信息</h3><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li><li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li><li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h3 id="2-arp-解析-mac-地址"><a class="markdownIt-Anchor" href="#2-arp-解析-mac-地址"></a> 2. ARP 解析 MAC 地址</h3><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li><li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li></ul><h3 id="3-dns-解析域名"><a class="markdownIt-Anchor" href="#3-dns-解析域名"></a> 3. DNS 解析域名</h3><ul><li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li><li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li><li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li><li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li></ul><h3 id="4-http-请求页面"><a class="markdownIt-Anchor" href="#4-http-请求页面"></a> 4. HTTP 请求页面</h3><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络之应用层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络之应用层&quot;&gt;&lt;/a&gt; 计算机网络之应用层&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之数据链路层</title>
    <link href="https://dunwu.github.io/blog/network/network-data-link/"/>
    <id>https://dunwu.github.io/blog/network/network-data-link/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络之数据链路层"><a class="markdownIt-Anchor" href="#计算机网络之数据链路层"></a> 计算机网络之数据链路层</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p><strong>数据链路层（Data Link Layer）</strong> - 网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p><ul><li>主要协议：<code>PPP</code>、<code>CSMA/CD</code> 等。</li><li>数据单元：帧（frame）。</li><li>典型设备：二层交换机、网桥、网卡。</li></ul></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">基本问题</a><ul><li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">封装成帧</a></li><li><a href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">透明传输</a></li><li><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B">差错检测</a></li></ul></li><li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93">点对点信道</a><ul><li><a href="#ppp-%E5%8D%8F%E8%AE%AE">PPP 协议</a></li></ul></li><li><a href="#%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93">广播信道</a><ul><li><a href="#csmacd-%E5%8D%8F%E8%AE%AE">CSMA/CD 协议</a></li></ul></li><li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91">以太网</a></li><li><a href="#mac-%E5%9C%B0%E5%9D%80">MAC 地址</a></li><li><a href="#%E8%AE%BE%E5%A4%87">设备</a><ul><li><a href="#%E9%80%82%E9%85%8D%E5%99%A8">适配器</a></li><li><a href="#%E9%9B%86%E7%BA%BF%E5%99%A8">集线器</a></li><li><a href="#%E7%BD%91%E6%A1%A5">网桥</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA">以太网交换机</a></li></ul></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>链路是从一个节点到相邻节点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（网络适配器）和软件（协议）。</li><li>数据链路层三个基本问题：封装成帧、透明传输、差错检测。</li><li>数据链路层有两种信道类型：点对点信道（主要使用 <code>PPP</code>）和广播信道（主要使用 <code>CSMA/CD</code>）。</li><li>以太网 MAC 层的地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用及使用场合。</li></ul><h2 id="基本问题"><a class="markdownIt-Anchor" href="#基本问题"></a> 基本问题</h2><h3 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h3><p>为网络层传下来的 IP 数据报添加首部和尾部，用于标记帧的开始和结束。</p><p>为了提高传输效率，应该让数据部分长度尽可能大于首部和尾部。但是，每种链路层协议都限制了帧的数据部分长度上线——最大传送单元 MTU（Maximum Transfer Unit）</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/数据链路帧.png"/></div><h3 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h3><p><strong>透明</strong>表示：某一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/经过字节填充后发送的数据.png"/></div><h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3><p>目前数据链路层广泛使用了<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C" target="_blank" rel="noopener"><strong>循环冗余检验 CRC（Cyclic redundancy check）</strong></a>来检查比特差错。</p><h2 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h2><p>点对点信道使用一对一的点对点通信方式。</p><p>对于点对点的链路，点对点协议 PPP（Point-to-Point Protocol）是使用最广泛的数据链路层协议。</p><h3 id="ppp-协议"><a class="markdownIt-Anchor" href="#ppp-协议"></a> PPP 协议</h3><p>互联网用户通常都要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/PPP协议.png"/></div><p>PPP（点到点协议）是为在同等单元之间传输数据包这样的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/PPP帧.png"/></div><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><h2 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h2><p>广播信道(broadcast channel)是通过广播的方式传输信息的信息通道。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h3><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。发送前监听，如果忙则等待，如果空闲则发送。</li><li><strong>碰撞检测</strong> ：即边发送边检测。若检测到信道有干扰信号，则表示产生了碰撞，于是就要停止发送数据，计算出退避等待时间，然后使用 CSMA 方法继续尝试发送。计算退避等待时间采用的是<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二进制指数退避算法</a>。</li></ul><h2 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h2><p>局域网 LAN（Local Area Network）是指在某一区域内由多台计算机互联成的计算机组。</p><p>局域网的拓扑结构通常为总线型和环型。</p><p>局域网技术主要有：以太网、令牌环网、FDDI 网和无线局域网等。</p><h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2><p>以太网（Ethernet）是一种星型拓扑结构局域网。</p><p>以太网是目前应用最广泛的局域网。</p><p>以太网使用 CSMA/CD 协议。</p><h2 id="mac-地址"><a class="markdownIt-Anchor" href="#mac-地址"></a> MAC 地址</h2><p>MAC 地址（Media Access Control Address），也称为以太网地址或物理地址，它是一个用来确认网上设备位置的地址。</p><p>MAC 地址长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/data-link/MAC帧.png"/></div><h2 id="设备"><a class="markdownIt-Anchor" href="#设备"></a> 设备</h2><h3 id="适配器"><a class="markdownIt-Anchor" href="#适配器"></a> 适配器</h3><p>网络适配器一般指网卡。</p><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的 I/O 总线以并行传输方式进行。</p><h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3><p>集线器（Hub）的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p><p>使用集线器可以在物理层扩展以太网。</p><h3 id="网桥"><a class="markdownIt-Anchor" href="#网桥"></a> 网桥</h3><p>网桥（Bridge）是早期的两端口二层网络设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。</p><h3 id="以太网交换机"><a class="markdownIt-Anchor" href="#以太网交换机"></a> 以太网交换机</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><ul><li>以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。</li><li>交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</li><li>用户独占传输媒体的带宽，若一个接口到主机的带宽是 10Mbit 每秒，那么有 10 个接口的交换机的总容量是 100Mbit 每秒。这是交换机的最大优点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络之数据链路层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络之数据链路层&quot;&gt;&lt;/a&gt; 计算机网络之数据链路层&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之网络层</title>
    <link href="https://dunwu.github.io/blog/network/network-network/"/>
    <id>https://dunwu.github.io/blog/network/network-network/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络之网络层"><a class="markdownIt-Anchor" href="#计算机网络之网络层"></a> 计算机网络之网络层</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p><strong>网络层（network layer）</strong> - 为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</p><ul><li>主要协议：<code>IP</code>、<code>ICMP</code>。</li><li>数据单元：IP 数据报（packet）。</li><li>典型设备：网关、路由器。</li></ul></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#ip-%E5%8D%8F%E8%AE%AE">IP 协议</a><ul><li><a href="#%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE">相关协议</a></li><li><a href="#%E5%88%86%E7%B1%BB%E7%9A%84-ip-%E5%9C%B0%E5%9D%80">分类的 IP 地址</a></li><li><a href="#ip-%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">IP 地址与物理地址</a></li><li><a href="#ip-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F">IP 数据报格式</a></li></ul></li><li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-arp">地址解析协议 ARP</a></li><li><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp">网际控制报文协议 ICMP</a><ul><li><a href="#1-ping">1. Ping</a></li><li><a href="#2-traceroute">2. Traceroute</a></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91-vpn">虚拟专用网 VPN</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-nat">网络地址转换 NAT</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84">路由器的结构</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B">路由器分组转发流程</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE">路由选择协议</a><ul><li><a href="#1-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-rip">1. 内部网关协议 RIP</a></li><li><a href="#2-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-ospf">2. 内部网关协议 OSPF</a></li><li><a href="#3-%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE-bgp">3. 外部网关协议 BGP</a></li></ul></li></ul><!-- /TOC --><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程间通信的可靠性由运输层负责。</p><h2 id="ip-协议"><a class="markdownIt-Anchor" href="#ip-协议"></a> IP 协议</h2><p>网际协议 IP (Internet Protocol) 定义了三种功能：</p><ol><li>IP 定义了在 TCP/IP 互联网上数据传送的基本单元和数据格式。</li><li>IP 软件完成路由选择功能，选择数据传送的路径。</li><li>IP 包含了一组不可靠分组传送的规则，指明了分组处理、差错信息发生以及分组的规则。</li></ol><h3 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h3><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550912617336.png"/></div><h3 id="分类的-ip-地址"><a class="markdownIt-Anchor" href="#分类的-ip-地址"></a> 分类的 IP 地址</h3><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h4 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1. 分类</h4><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086738403.png"/></div><h4 id="2-子网划分"><a class="markdownIt-Anchor" href="#2-子网划分"></a> 2. 子网划分</h4><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><h4 id="3-无分类"><a class="markdownIt-Anchor" href="#3-无分类"></a> 3. 无分类</h4><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h3 id="ip-地址与物理地址"><a class="markdownIt-Anchor" href="#ip-地址与物理地址"></a> IP 地址与物理地址</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551088476626.png"/></div><ul><li>物理地址是数据链路层和物理层使用的地址。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551088631948.png"/></div><h3 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550913213250.png"/></div><ul><li><strong>版本</strong> - 有 4（IPv4）和 6（IPv6）两个值。</li><li><strong>首部长度</strong> - 占 4 位，因此最大十进制数值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> - 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> - 包括首部长度和数据部分长度。占 16 位，因此数据报的最大长度为 2 <sup>16</sup> - 1 = 65535 字节。</li><li><strong>生存时间</strong> - TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> - 指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> - 因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> - 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> - 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1550913364479.png"/></div><h2 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086787261.png"/></div><p>ARP 实现由 IP 地址得到 MAC 地址。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086769846.png"/></div><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086833117.png"/></div><h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086857345.png"/></div><p>ICMP 报文分为差错报告报文和询问报文。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086870897.png"/></div><h3 id="1-ping"><a class="markdownIt-Anchor" href="#1-ping"></a> 1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h3 id="2-traceroute"><a class="markdownIt-Anchor" href="#2-traceroute"></a> 2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#虚拟专用网-vpn"></a> 虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086901339.png"/></div><h2 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h2 id="路由器的结构"><a class="markdownIt-Anchor" href="#路由器的结构"></a> 路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086930371.png"/></div><h2 id="路由器分组转发流程"><a class="markdownIt-Anchor" href="#路由器分组转发流程"></a> 路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086952828.png"/></div><h2 id="路由选择协议"><a class="markdownIt-Anchor" href="#路由选择协议"></a> 路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><h3 id="1-内部网关协议-rip"><a class="markdownIt-Anchor" href="#1-内部网关协议-rip"></a> 1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-ospf"><a class="markdownIt-Anchor" href="#2-内部网关协议-ospf"></a> 2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议-bgp"><a class="markdownIt-Anchor" href="#3-外部网关协议-bgp"></a> 3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/network/1551086977310.png"/></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络之网络层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络之网络层&quot;&gt;&lt;/a&gt; 计算机网络之网络层&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之物理层</title>
    <link href="https://dunwu.github.io/blog/network/network-physical/"/>
    <id>https://dunwu.github.io/blog/network/network-physical/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络之物理层"><a class="markdownIt-Anchor" href="#计算机网络之物理层"></a> 计算机网络之物理层</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p><strong>摘要</strong></p><p><strong>物理层（Physical Layer）</strong> - 物理层只接收和发送一串比特(bit)流，不考虑信息的意义和信息结构。</p><ul><li>数据单元：比特流。</li><li>典型设备：光纤、同轴电缆、双绞线、中继器和集线器。</li></ul></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B">通信系统模型</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7">通信信号</a></li><li><a href="#%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83">调制解调</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95">基本带通调制方法</a></li></ul></li><li><a href="#%E9%80%9A%E4%BF%A1%E5%AA%92%E4%BB%8B">通信媒介</a></li><li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8">信道复用</a></li></ul><!-- /TOC --><h2 id="通信系统模型"><a class="markdownIt-Anchor" href="#通信系统模型"></a> 通信系统模型</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/数据通信系统的模型.png"/></div><p>通信系统模型分为三大部分：源系统（包括信源和发送器）、传输系统、目的系统（包括信宿接收器）。</p><p>重要概念：</p><ul><li><strong>信源</strong> - 也叫源点。产生各类信息的实体。</li><li><strong>信道</strong> - 通信的通道，是信号传输的媒介。</li><li><strong>信宿</strong> - 传输信息的归宿。</li><li><strong>码元</strong> - 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为(二进制）码元。</li></ul><h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/通信方式.jpg"/></div><p>有三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="通信信号"><a class="markdownIt-Anchor" href="#通信信号"></a> 通信信号</h2><p>通信的目的是传送消息。如语音、文字、图像、视频都是消息。数据时传送消息的实体。信号是数据的电气或电磁的表现。</p><p>模拟信号和数字信号</p><ul><li><strong>模拟信号</strong> - 模拟信号是连续的信号。</li><li><strong>数字信号</strong> - 数字信号是离散的信号。</li></ul><h2 id="调制解调"><a class="markdownIt-Anchor" href="#调制解调"></a> 调制解调</h2><p>重要概念：</p><ul><li><strong>基带信号</strong> - 来自信源的信号叫做基带信号。</li><li><strong>调制</strong> - 将各种数字基带信号转换成适于信道传输的数字调制信号(已调信号或频带信号)。简单来说：调制即，数字 -&gt; 模拟。</li><li><strong>解调</strong> - 在接收端将收到的数字频带信号还原成数字基带信号。简单来说：解调即，模拟 -&gt; 数字。</li></ul><blockquote><p>📌 提示：我们上网时所用到的调制解调器（俗称“猫”），指的就是转换数字和模拟信号的机器。</p></blockquote><p>信号要在信道上传输就要经过调制。</p><p>调制分为：基带调制和带通调制</p><h3 id="基本带通调制方法"><a class="markdownIt-Anchor" href="#基本带通调制方法"></a> 基本带通调制方法</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/physical/基本调制方法.png"/></div><p>如果你收听过广播，一定经常听到 AM、FM 这两个关键词，这是什么意思呢？答案如下：</p><ul><li><strong>调幅（AM）</strong> - 即载波的<strong>振幅</strong>随基带数字信号而变化。</li><li><strong>调频（FM）</strong> - 即载波的<strong>频率</strong>随基带数字信号而变化。</li><li><strong>调相（PM）</strong> - 即载波的<strong>初始相位</strong>随基带数字信号而变化。</li></ul><blockquote><p>📌 提示：我们收听广播时，为了接收不同广播台的信号，就要调整 AM 或 FM，指的就是这里的调制方法。</p></blockquote><h2 id="通信媒介"><a class="markdownIt-Anchor" href="#通信媒介"></a> 通信媒介</h2><p>通信媒介分为两大类：</p><ul><li>导引型 - 双绞线、电缆、光纤</li><li>非导引型 - 无线、红外线、大气、激光</li></ul><h2 id="信道复用"><a class="markdownIt-Anchor" href="#信道复用"></a> 信道复用</h2><p>信道复用就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。</p><ul><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络之物理层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络之物理层&quot;&gt;&lt;/a&gt; 计算机网络之物理层&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之传输层</title>
    <link href="https://dunwu.github.io/blog/network/network-transport/"/>
    <id>https://dunwu.github.io/blog/network/network-transport/</id>
    <published>2019-03-05T16:00:00.000Z</published>
    <updated>2021-08-26T15:33:01.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络之传输层"><a class="markdownIt-Anchor" href="#计算机网络之传输层"></a> 计算机网络之传输层</h1><blockquote><p>📦 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#udp-%E5%92%8C-tcp-%E7%9A%84%E7%89%B9%E7%82%B9">UDP 和 TCP 的特点</a></li><li><a href="#udp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">UDP 首部格式</a></li><li><a href="#tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP 首部格式</a></li><li><a href="#tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP 的三次握手</a></li><li><a href="#tcp-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 的四次挥手</a></li><li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a></li><li><a href="#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">TCP 滑动窗口</a></li><li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a></li><li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a><ul><li><a href="#1-%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D">1. 慢开始与拥塞避免</a></li><li><a href="#2-%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D">2. 快重传与快恢复</a></li></ul></li></ul><!-- /TOC --><h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></li></ul><h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092392065.png"/></div><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092419042.png"/></div><ul><li><p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092794258.png"/></div><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092825974.png"/></div><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p></li></ul><h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"/></div> <br><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"/></div> <br><p>其中 RTT<sub>d</sub> 为偏差的加权平均值。</p><h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092841802.png"/></div><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="tcp-拥塞控制"><a class="markdownIt-Anchor" href="#tcp-拥塞控制"></a> TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551092981695.png"/></div><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551093119265.png"/></div><h3 id="1-慢开始与拥塞避免"><a class="markdownIt-Anchor" href="#1-慢开始与拥塞避免"></a> 1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><h3 id="2-快重传与快恢复"><a class="markdownIt-Anchor" href="#2-快重传与快恢复"></a> 2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/network/transport/1551093167163.png"/></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络之传输层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络之传输层&quot;&gt;&lt;/a&gt; 计算机网络之传输层&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📦 本文已归档到：「&lt;a href=&quot;https://github.com
      
    
    </summary>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://dunwu.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="通信" scheme="https://dunwu.github.io/blog/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
</feed>
